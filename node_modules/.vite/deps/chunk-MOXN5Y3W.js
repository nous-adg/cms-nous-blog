// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/underscore-DjQrhefX.mjs
function snakeToCamel(str) {
  return str ? str.replace(/([-_][a-z])/g, (match) => match.toUpperCase().replace(/-|_/, "")) : "";
}
function camelToSnake(str) {
  return str ? str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`) : "";
}
var createDeepObjectTransformer = (transform) => {
  const deepTransform = (obj) => {
    if (!obj) return obj;
    if (Array.isArray(obj)) return obj.map((el) => {
      if (typeof el === "object" || Array.isArray(el)) return deepTransform(el);
      return el;
    });
    const copy = { ...obj };
    const keys = Object.keys(copy);
    for (const oldName of keys) {
      const newName = transform(oldName.toString());
      if (newName !== oldName) {
        copy[newName] = copy[oldName];
        delete copy[oldName];
      }
      if (typeof copy[newName] === "object") copy[newName] = deepTransform(copy[newName]);
    }
    return copy;
  };
  return deepTransform;
};
var deepCamelToSnake = createDeepObjectTransformer(camelToSnake);
var deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);
function isTruthy(value) {
  if (typeof value === `boolean`) return value;
  if (value === void 0 || value === null) return false;
  if (typeof value === `string`) {
    if (value.toLowerCase() === `true`) return true;
    if (value.toLowerCase() === `false`) return false;
  }
  const number = parseInt(value, 10);
  if (isNaN(number)) return false;
  if (number > 0) return true;
  return false;
}

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/deriveState-ChDqlleE.mjs
var deriveState = (clerkOperational, state, initialState) => {
  if (!clerkOperational && initialState) return deriveFromSsrInitialState(initialState);
  return deriveFromClientSideState(state);
};
var deriveFromSsrInitialState = (initialState) => {
  const userId = initialState.userId;
  const user = initialState.user;
  const sessionId = initialState.sessionId;
  const sessionStatus = initialState.sessionStatus;
  const sessionClaims = initialState.sessionClaims;
  return {
    userId,
    user,
    sessionId,
    session: initialState.session,
    sessionStatus,
    sessionClaims,
    organization: initialState.organization,
    orgId: initialState.orgId,
    orgRole: initialState.orgRole,
    orgPermissions: initialState.orgPermissions,
    orgSlug: initialState.orgSlug,
    actor: initialState.actor,
    factorVerificationAge: initialState.factorVerificationAge
  };
};
var deriveFromClientSideState = (state) => {
  const userId = state.user ? state.user.id : state.user;
  const user = state.user;
  const sessionId = state.session ? state.session.id : state.session;
  const session = state.session;
  const sessionStatus = state.session?.status;
  const sessionClaims = state.session ? state.session.lastActiveToken?.jwt?.claims : null;
  const factorVerificationAge = state.session ? state.session.factorVerificationAge : null;
  const actor = session?.actor;
  const organization = state.organization;
  const orgId = state.organization ? state.organization.id : state.organization;
  const orgSlug = organization?.slug;
  const membership = organization ? user?.organizationMemberships?.find((om) => om.organization.id === orgId) : organization;
  const orgPermissions = membership ? membership.permissions : membership;
  return {
    userId,
    user,
    sessionId,
    session,
    sessionStatus,
    sessionClaims,
    organization,
    orgId,
    orgRole: membership ? membership.role : membership,
    orgSlug,
    orgPermissions,
    actor,
    factorVerificationAge
  };
};

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/constants-ByUssRbE.mjs
var DEV_OR_STAGING_SUFFIXES = [
  ".lcl.dev",
  ".stg.dev",
  ".lclstage.dev",
  ".stgstage.dev",
  ".dev.lclclerk.com",
  ".stg.lclclerk.com",
  ".accounts.lclclerk.com",
  "accountsstage.dev",
  "accounts.dev"
];

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/isomorphicAtob-DybBXGFR.mjs
var isomorphicAtob = (data) => {
  if (typeof atob !== "undefined" && typeof atob === "function") return atob(data);
  else if (typeof global !== "undefined" && global.Buffer) return new global.Buffer(data, "base64").toString();
  return data;
};

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/keys-YNv6yjKk.mjs
var PUBLISHABLE_KEY_LIVE_PREFIX = "pk_live_";
var PUBLISHABLE_KEY_TEST_PREFIX = "pk_test_";
function isValidDecodedPublishableKey(decoded) {
  if (!decoded.endsWith("$")) return false;
  const withoutTrailing = decoded.slice(0, -1);
  if (withoutTrailing.includes("$")) return false;
  return withoutTrailing.includes(".");
}
function parsePublishableKey(key, options = {}) {
  key = key || "";
  if (!key || !isPublishableKey(key)) {
    if (options.fatal && !key) throw new Error("Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys");
    if (options.fatal && !isPublishableKey(key)) throw new Error("Publishable key not valid.");
    return null;
  }
  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? "production" : "development";
  let decodedFrontendApi;
  try {
    decodedFrontendApi = isomorphicAtob(key.split("_")[2]);
  } catch {
    if (options.fatal) throw new Error("Publishable key not valid: Failed to decode key.");
    return null;
  }
  if (!isValidDecodedPublishableKey(decodedFrontendApi)) {
    if (options.fatal) throw new Error("Publishable key not valid: Decoded key has invalid format.");
    return null;
  }
  let frontendApi = decodedFrontendApi.slice(0, -1);
  if (options.proxyUrl) frontendApi = options.proxyUrl;
  else if (instanceType !== "development" && options.domain && options.isSatellite) frontendApi = `clerk.${options.domain}`;
  return {
    instanceType,
    frontendApi
  };
}
function isPublishableKey(key = "") {
  try {
    if (!(key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX))) return false;
    const parts = key.split("_");
    if (parts.length !== 3) return false;
    const encodedPart = parts[2];
    if (!encodedPart) return false;
    return isValidDecodedPublishableKey(isomorphicAtob(encodedPart));
  } catch {
    return false;
  }
}
function createDevOrStagingUrlCache() {
  const devOrStagingUrlCache = /* @__PURE__ */ new Map();
  return { isDevOrStagingUrl: (url) => {
    if (!url) return false;
    const hostname = typeof url === "string" ? url : url.hostname;
    let res = devOrStagingUrlCache.get(hostname);
    if (res === void 0) {
      res = DEV_OR_STAGING_SUFFIXES.some((s) => hostname.endsWith(s));
      devOrStagingUrlCache.set(hostname, res);
    }
    return res;
  } };
}

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/telemetry-wqMDWlvR.mjs
var EVENT_METHOD_CALLED = "METHOD_CALLED";
var EVENT_SAMPLING_RATE$2 = 0.1;
function eventMethodCalled(method, payload) {
  return {
    event: EVENT_METHOD_CALLED,
    eventSamplingRate: EVENT_SAMPLING_RATE$2,
    payload: {
      method,
      ...payload
    }
  };
}

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/clean-stores/index.js
var clean = Symbol("clean");

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/atom/index.js
var listenerQueue = [];
var lqIndex = 0;
var QUEUE_ITEMS_PER_LISTENER = 4;
var epoch = 0;
var atom = (initialValue) => {
  let listeners = [];
  let $atom = {
    get() {
      if (!$atom.lc) {
        $atom.listen(() => {
        })();
      }
      return $atom.value;
    },
    lc: 0,
    listen(listener) {
      $atom.lc = listeners.push(listener);
      return () => {
        for (let i = lqIndex + QUEUE_ITEMS_PER_LISTENER; i < listenerQueue.length; ) {
          if (listenerQueue[i] === listener) {
            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER);
          } else {
            i += QUEUE_ITEMS_PER_LISTENER;
          }
        }
        let index = listeners.indexOf(listener);
        if (~index) {
          listeners.splice(index, 1);
          if (!--$atom.lc) $atom.off();
        }
      };
    },
    notify(oldValue, changedKey) {
      epoch++;
      let runListenerQueue = !listenerQueue.length;
      for (let listener of listeners) {
        listenerQueue.push(listener, $atom.value, oldValue, changedKey);
      }
      if (runListenerQueue) {
        for (lqIndex = 0; lqIndex < listenerQueue.length; lqIndex += QUEUE_ITEMS_PER_LISTENER) {
          listenerQueue[lqIndex](
            listenerQueue[lqIndex + 1],
            listenerQueue[lqIndex + 2],
            listenerQueue[lqIndex + 3]
          );
        }
        listenerQueue.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(newValue) {
      let oldValue = $atom.value;
      if (oldValue !== newValue) {
        $atom.value = newValue;
        $atom.notify(oldValue);
      }
    },
    subscribe(listener) {
      let unbind = $atom.listen(listener);
      listener($atom.value);
      return unbind;
    },
    value: initialValue
  };
  if (true) {
    $atom[clean] = () => {
      listeners = [];
      $atom.lc = 0;
      $atom.off();
    };
  }
  return $atom;
};

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/lifecycle/index.js
var MOUNT = 5;
var UNMOUNT = 6;
var REVERT_MUTATION = 10;
var on = (object, listener, eventKey, mutateStore) => {
  object.events = object.events || {};
  if (!object.events[eventKey + REVERT_MUTATION]) {
    object.events[eventKey + REVERT_MUTATION] = mutateStore((eventProps) => {
      object.events[eventKey].reduceRight((event, l) => (l(event), event), {
        shared: {},
        ...eventProps
      });
    });
  }
  object.events[eventKey] = object.events[eventKey] || [];
  object.events[eventKey].push(listener);
  return () => {
    let currentListeners = object.events[eventKey];
    let index = currentListeners.indexOf(listener);
    currentListeners.splice(index, 1);
    if (!currentListeners.length) {
      delete object.events[eventKey];
      object.events[eventKey + REVERT_MUTATION]();
      delete object.events[eventKey + REVERT_MUTATION];
    }
  };
};
var STORE_UNMOUNT_DELAY = 1e3;
var onMount = ($store, initialize) => {
  let listener = (payload) => {
    let destroy = initialize(payload);
    if (destroy) $store.events[UNMOUNT].push(destroy);
  };
  return on($store, listener, MOUNT, (runListeners) => {
    let originListen = $store.listen;
    $store.listen = (...args) => {
      if (!$store.lc && !$store.active) {
        $store.active = true;
        runListeners();
      }
      return originListen(...args);
    };
    let originOff = $store.off;
    $store.events[UNMOUNT] = [];
    $store.off = () => {
      originOff();
      setTimeout(() => {
        if ($store.active && !$store.lc) {
          $store.active = false;
          for (let destroy of $store.events[UNMOUNT]) destroy();
          $store.events[UNMOUNT] = [];
        }
      }, STORE_UNMOUNT_DELAY);
    };
    if (true) {
      let originClean = $store[clean];
      $store[clean] = () => {
        for (let destroy of $store.events[UNMOUNT]) destroy();
        $store.events[UNMOUNT] = [];
        $store.active = false;
        originClean();
      };
    }
    return () => {
      $store.listen = originListen;
      $store.off = originOff;
    };
  });
};

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/computed/index.js
var computedStore = (stores, cb, batched2) => {
  if (!Array.isArray(stores)) stores = [stores];
  let previousArgs;
  let currentEpoch;
  let set = () => {
    if (currentEpoch === epoch) return;
    currentEpoch = epoch;
    let args = stores.map(($store) => $store.get());
    if (!previousArgs || args.some((arg, i) => arg !== previousArgs[i])) {
      previousArgs = args;
      let value = cb(...args);
      if (value && value.then && value.t) {
        value.then((asyncValue) => {
          if (previousArgs === args) {
            $computed.set(asyncValue);
          }
        });
      } else {
        $computed.set(value);
        currentEpoch = epoch;
      }
    }
  };
  let $computed = atom(void 0);
  let get = $computed.get;
  $computed.get = () => {
    set();
    return get();
  };
  let timer;
  let run = batched2 ? () => {
    clearTimeout(timer);
    timer = setTimeout(set);
  } : set;
  onMount($computed, () => {
    let unbinds = stores.map(($store) => $store.listen(run));
    set();
    return () => {
      for (let unbind of unbinds) unbind();
    };
  });
  return $computed;
};
var computed = (stores, fn) => computedStore(stores, fn);
var batched = (stores, fn) => computedStore(stores, fn, true);

// node_modules/.pnpm/nanostores@1.0.1/node_modules/nanostores/map/index.js
var map = (initial = {}) => {
  let $map = atom(initial);
  $map.setKey = function(key, value) {
    let oldMap = $map.value;
    if (typeof value === "undefined" && key in $map.value) {
      $map.value = { ...$map.value };
      delete $map.value[key];
      $map.notify(oldMap, key);
    } else if ($map.value[key] !== value) {
      $map.value = {
        ...$map.value,
        [key]: value
      };
      $map.notify(oldMap, key);
    }
  };
  return $map;
};

// node_modules/.pnpm/@clerk+astro@2.16.7_astro@5.16.5_@types+node@25.0.0_jiti@2.6.1_lightningcss@1.30.2_roll_d171ee5556e8a687526ed121174c4d2b/node_modules/@clerk/astro/dist/chunk-MZTESQVU.js
var $csrState = map({
  isLoaded: false,
  client: void 0,
  user: void 0,
  session: void 0,
  organization: void 0
});
var $initialState = map();
var $clerk = atom(null);
var $isLoadedStore = computed([$csrState], (state) => state.isLoaded);
var $authStore = batched([$csrState, $initialState], (state, initialState) => {
  return deriveState(
    state.isLoaded,
    {
      session: state.session,
      user: state.user,
      organization: state.organization,
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      client: state.client
    },
    initialState
  );
});
var $userStore = computed([$authStore], (auth) => auth.user);
var $sessionStore = computed([$authStore], (auth) => auth.session);
var $organizationStore = computed([$authStore], (auth) => auth.organization);
var $clientStore = computed([$csrState], (csr) => csr.client);
var $clerkStore = computed([$clerk], (clerk) => clerk);
var $sessionListStore = computed([$clientStore], (client) => client?.sessions);
var $signInStore = computed([$clientStore], (client) => client?.signIn);
var $signUpStore = computed([$clientStore], (client) => client?.signUp);
var recordTelemetryEvent = (store, method) => {
  onMount(store, () => {
    $clerk.get()?.telemetry?.record(eventMethodCalled(method));
  });
};
recordTelemetryEvent($signInStore, "$signInStore");
recordTelemetryEvent($signUpStore, "$signUpStore");
recordTelemetryEvent($organizationStore, "$organizationStore");

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/error-CC05ENkI.mjs
function createErrorTypeGuard(ErrorClass) {
  function typeGuard(error) {
    const target = error ?? this;
    if (!target) throw new TypeError(`${ErrorClass.kind || ErrorClass.name} type guard requires an error object`);
    return target instanceof ErrorClass;
  }
  return typeGuard;
}
var ClerkAPIError = class {
  static kind = "ClerkApiError";
  code;
  message;
  longMessage;
  meta;
  constructor(json) {
    const parsedError = {
      code: json.code,
      message: json.message,
      longMessage: json.long_message,
      meta: {
        paramName: json.meta?.param_name,
        sessionId: json.meta?.session_id,
        emailAddresses: json.meta?.email_addresses,
        identifiers: json.meta?.identifiers,
        zxcvbn: json.meta?.zxcvbn,
        plan: json.meta?.plan,
        isPlanUpgradePossible: json.meta?.is_plan_upgrade_possible
      }
    };
    this.code = parsedError.code;
    this.message = parsedError.message;
    this.longMessage = parsedError.longMessage;
    this.meta = parsedError.meta;
  }
};
var isClerkApiError = createErrorTypeGuard(ClerkAPIError);
var ClerkError = class ClerkError2 extends Error {
  static kind = "ClerkError";
  clerkError = true;
  code;
  longMessage;
  docsUrl;
  cause;
  get name() {
    return this.constructor.name;
  }
  constructor(opts) {
    super(new.target.formatMessage(new.target.kind, opts.message, opts.code, opts.docsUrl), { cause: opts.cause });
    Object.setPrototypeOf(this, ClerkError2.prototype);
    this.code = opts.code;
    this.docsUrl = opts.docsUrl;
    this.longMessage = opts.longMessage;
    this.cause = opts.cause;
  }
  toString() {
    return `[${this.name}]
Message:${this.message}`;
  }
  static formatMessage(name, msg, code, docsUrl) {
    const prefix = "Clerk:";
    const regex = new RegExp(prefix.replace(" ", "\\s*"), "i");
    msg = msg.replace(regex, "");
    msg = `${prefix} ${msg.trim()}

(code="${code}")

`;
    if (docsUrl) msg += `

Docs: ${docsUrl}`;
    return msg;
  }
};
var ClerkAPIResponseError = class ClerkAPIResponseError2 extends ClerkError {
  static kind = "ClerkAPIResponseError";
  status;
  clerkTraceId;
  retryAfter;
  errors;
  constructor(message, options) {
    const { data: errorsJson, status, clerkTraceId, retryAfter } = options;
    super({
      ...options,
      message,
      code: "api_response_error"
    });
    Object.setPrototypeOf(this, ClerkAPIResponseError2.prototype);
    this.status = status;
    this.clerkTraceId = clerkTraceId;
    this.retryAfter = retryAfter;
    this.errors = (errorsJson || []).map((e) => new ClerkAPIError(e));
  }
  toString() {
    let message = `[${this.name}]
Message:${this.message}
Status:${this.status}
Serialized errors: ${this.errors.map((e) => JSON.stringify(e))}`;
    if (this.clerkTraceId) message += `
Clerk Trace ID: ${this.clerkTraceId}`;
    return message;
  }
  static formatMessage(name, msg, _, __) {
    return msg;
  }
};
var isClerkApiResponseError = createErrorTypeGuard(ClerkAPIResponseError);
var DefaultMessages = Object.freeze({
  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,
  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,
  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,
  MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`
});
function buildErrorThrower({ packageName, customMessages }) {
  let pkg = packageName;
  function buildMessage(rawMessage, replacements) {
    if (!replacements) return `${pkg}: ${rawMessage}`;
    let msg = rawMessage;
    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);
    for (const match of matches) {
      const replacement = (replacements[match[1]] || "").toString();
      msg = msg.replace(`{{${match[1]}}}`, replacement);
    }
    return `${pkg}: ${msg}`;
  }
  const messages = {
    ...DefaultMessages,
    ...customMessages
  };
  return {
    setPackageName({ packageName: packageName$1 }) {
      if (typeof packageName$1 === "string") pkg = packageName$1;
      return this;
    },
    setMessages({ customMessages: customMessages$1 }) {
      Object.assign(messages, customMessages$1 || {});
      return this;
    },
    throwInvalidPublishableKeyError(params) {
      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));
    },
    throwInvalidProxyUrl(params) {
      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));
    },
    throwMissingPublishableKeyError() {
      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));
    },
    throwMissingSecretKeyError() {
      throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));
    },
    throwMissingClerkProviderError(params) {
      throw new Error(buildMessage(messages.MissingClerkProvider, params));
    },
    throw(message) {
      throw new Error(buildMessage(message));
    }
  };
}
var ClerkRuntimeError = class ClerkRuntimeError2 extends ClerkError {
  static kind = "ClerkRuntimeError";
  /**
  * @deprecated Use `clerkError` property instead. This property is maintained for backward compatibility.
  */
  clerkRuntimeError = true;
  constructor(message, options) {
    super({
      ...options,
      message
    });
    Object.setPrototypeOf(this, ClerkRuntimeError2.prototype);
  }
};
var isClerkRuntimeError$1 = createErrorTypeGuard(ClerkRuntimeError);

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/retry-DAlTROH9.mjs
var defaultOptions = {
  initialDelay: 125,
  maxDelayBetweenRetries: 0,
  factor: 2,
  shouldRetry: (_, iteration) => iteration < 5,
  retryImmediately: false,
  jitter: true
};
var RETRY_IMMEDIATELY_DELAY = 100;
var sleep = async (ms) => new Promise((s) => setTimeout(s, ms));
var applyJitter = (delay, jitter) => {
  return jitter ? delay * (1 + Math.random()) : delay;
};
var createExponentialDelayAsyncFn = (opts) => {
  let timesCalled = 0;
  const calculateDelayInMs = () => {
    const constant = opts.initialDelay;
    const base = opts.factor;
    let delay = constant * Math.pow(base, timesCalled);
    delay = applyJitter(delay, opts.jitter);
    return Math.min(opts.maxDelayBetweenRetries || delay, delay);
  };
  return async () => {
    await sleep(calculateDelayInMs());
    timesCalled++;
  };
};
var retry = async (callback, options = {}) => {
  let iterations = 0;
  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter, onBeforeRetry } = {
    ...defaultOptions,
    ...options
  };
  const delay = createExponentialDelayAsyncFn({
    initialDelay,
    maxDelayBetweenRetries,
    factor,
    jitter
  });
  while (true) try {
    return await callback();
  } catch (e) {
    iterations++;
    if (!shouldRetry(e, iterations)) throw e;
    if (onBeforeRetry) await onBeforeRetry(iterations);
    if (retryImmediately && iterations === 1) await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));
    else await delay();
  }
};

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/loadScript-t1vaIfy5.mjs
var NO_DOCUMENT_ERROR = "loadScript cannot be called when document does not exist";
var NO_SRC_ERROR = "loadScript cannot be called without a src";
async function loadScript(src = "", opts) {
  const { async, defer, beforeLoad, crossOrigin, nonce } = opts || {};
  const load = () => {
    return new Promise((resolve, reject) => {
      if (!src) reject(new Error(NO_SRC_ERROR));
      if (!document || !document.body) reject(new Error(NO_DOCUMENT_ERROR));
      const script = document.createElement("script");
      if (crossOrigin) script.setAttribute("crossorigin", crossOrigin);
      script.async = async || false;
      script.defer = defer || false;
      script.addEventListener("load", () => {
        script.remove();
        resolve(script);
      });
      script.addEventListener("error", (event) => {
        script.remove();
        reject(event.error ?? new Error(`failed to load script: ${src}`));
      });
      script.src = src;
      script.nonce = nonce;
      beforeLoad?.(script);
      document.body.appendChild(script);
    });
  };
  return retry(load, { shouldRetry: (_, iterations) => iterations <= 5 });
}

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/proxy-Bq8EHApG.mjs
function isValidProxyUrl(key) {
  if (!key) return true;
  return isHttpOrHttps(key) || isProxyUrlRelative(key);
}
function isHttpOrHttps(key) {
  return /^http(s)?:\/\//.test(key || "");
}
function isProxyUrlRelative(key) {
  return key.startsWith("/");
}
function proxyUrlToAbsoluteURL(url) {
  if (!url) return "";
  return isProxyUrlRelative(url) ? new URL(url, window.location.origin).toString() : url;
}

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/url-Cdy8w8vK.mjs
function addClerkPrefix(str) {
  if (!str) return "";
  let regex;
  if (str.match(/^(clerk\.)+\w*$/)) regex = /(clerk\.)*(?=clerk\.)/;
  else if (str.match(/\.clerk.accounts/)) return str;
  else regex = /^(clerk\.)*/gi;
  return `clerk.${str.replace(regex, "")}`;
}

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/versionSelector-BijroOKG.mjs
var versionSelector = (clerkJSVersion, packageVersion = "5.114.0") => {
  if (clerkJSVersion) return clerkJSVersion;
  const prereleaseTag = getPrereleaseTag(packageVersion);
  if (prereleaseTag) {
    if (prereleaseTag === "snapshot") return "5.114.0";
    return prereleaseTag;
  }
  return getMajorVersion(packageVersion);
};
var getPrereleaseTag = (packageVersion) => packageVersion.trim().replace(/^v/, "").match(/-(.+?)(\.|$)/)?.[1];
var getMajorVersion = (packageVersion) => packageVersion.trim().replace(/^v/, "").split(".")[0];

// node_modules/.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/dist/runtime/loadClerkJsScript-BXAyt81H.mjs
var ERROR_CODE = "failed_to_load_clerk_js";
var ERROR_CODE_TIMEOUT = "failed_to_load_clerk_js_timeout";
var FAILED_TO_LOAD_ERROR = "Failed to load Clerk";
var { isDevOrStagingUrl } = createDevOrStagingUrlCache();
var errorThrower = buildErrorThrower({ packageName: "@clerk/shared" });
function setClerkJsLoadingErrorPackageName(packageName) {
  errorThrower.setPackageName({ packageName });
}
function isClerkProperlyLoaded() {
  if (typeof window === "undefined" || !window.Clerk) return false;
  const clerk = window.Clerk;
  return typeof clerk === "object" && typeof clerk.load === "function";
}
function hasScriptRequestError(scriptUrl) {
  if (typeof window === "undefined" || !window.performance) return false;
  const entries = performance.getEntriesByName(scriptUrl, "resource");
  if (entries.length === 0) return false;
  const scriptEntry = entries[entries.length - 1];
  if (scriptEntry.transferSize === 0 && scriptEntry.decodedBodySize === 0) {
    if (scriptEntry.responseEnd === 0) return true;
    if (scriptEntry.responseEnd > 0 && scriptEntry.responseStart > 0) return true;
    if ("responseStatus" in scriptEntry) {
      if (scriptEntry.responseStatus >= 400) return true;
      if (scriptEntry.responseStatus === 0) return true;
    }
  }
  return false;
}
function waitForClerkWithTimeout(timeoutMs, existingScript) {
  return new Promise((resolve, reject) => {
    let resolved = false;
    const cleanup = (timeoutId$1, pollInterval$1) => {
      clearTimeout(timeoutId$1);
      clearInterval(pollInterval$1);
    };
    existingScript?.addEventListener("error", () => {
      cleanup(timeoutId, pollInterval);
      reject(new ClerkRuntimeError(FAILED_TO_LOAD_ERROR, { code: ERROR_CODE }));
    });
    const checkAndResolve = () => {
      if (resolved) return;
      if (isClerkProperlyLoaded()) {
        resolved = true;
        cleanup(timeoutId, pollInterval);
        resolve(null);
      }
    };
    const handleTimeout = () => {
      if (resolved) return;
      resolved = true;
      cleanup(timeoutId, pollInterval);
      if (!isClerkProperlyLoaded()) reject(new ClerkRuntimeError(FAILED_TO_LOAD_ERROR, { code: ERROR_CODE_TIMEOUT }));
      else resolve(null);
    };
    const timeoutId = setTimeout(handleTimeout, timeoutMs);
    checkAndResolve();
    const pollInterval = setInterval(() => {
      if (resolved) {
        clearInterval(pollInterval);
        return;
      }
      checkAndResolve();
    }, 100);
  });
}
var loadClerkJsScript = async (opts) => {
  const timeout = opts?.scriptLoadTimeout ?? 15e3;
  if (isClerkProperlyLoaded()) return null;
  if (!opts?.publishableKey) {
    errorThrower.throwMissingPublishableKeyError();
    return null;
  }
  const scriptUrl = clerkJsScriptUrl(opts);
  const existingScript = document.querySelector("script[data-clerk-js-script]");
  if (existingScript) if (hasScriptRequestError(scriptUrl)) existingScript.remove();
  else try {
    await waitForClerkWithTimeout(timeout, existingScript);
    return null;
  } catch {
    existingScript.remove();
  }
  const loadPromise = waitForClerkWithTimeout(timeout);
  loadScript(scriptUrl, {
    async: true,
    crossOrigin: "anonymous",
    nonce: opts.nonce,
    beforeLoad: applyClerkJsScriptAttributes(opts)
  }).catch((error) => {
    throw new ClerkRuntimeError(FAILED_TO_LOAD_ERROR + (error.message ? `, ${error.message}` : ""), {
      code: ERROR_CODE,
      cause: error
    });
  });
  return loadPromise;
};
var clerkJsScriptUrl = (opts) => {
  const { clerkJSUrl, clerkJSVariant, clerkJSVersion, proxyUrl, domain, publishableKey } = opts;
  if (clerkJSUrl) return clerkJSUrl;
  let scriptHost = "";
  if (!!proxyUrl && isValidProxyUrl(proxyUrl)) scriptHost = proxyUrlToAbsoluteURL(proxyUrl).replace(/http(s)?:\/\//, "");
  else if (domain && !isDevOrStagingUrl(parsePublishableKey(publishableKey)?.frontendApi || "")) scriptHost = addClerkPrefix(domain);
  else scriptHost = parsePublishableKey(publishableKey)?.frontendApi || "";
  const variant = clerkJSVariant ? `${clerkJSVariant.replace(/\.+$/, "")}.` : "";
  const version = versionSelector(clerkJSVersion);
  return `https://${scriptHost}/npm/@clerk/clerk-js@${version}/dist/clerk.${variant}browser.js`;
};
var buildClerkJsScriptAttributes = (options) => {
  const obj = {};
  if (options.publishableKey) obj["data-clerk-publishable-key"] = options.publishableKey;
  if (options.proxyUrl) obj["data-clerk-proxy-url"] = options.proxyUrl;
  if (options.domain) obj["data-clerk-domain"] = options.domain;
  if (options.nonce) obj.nonce = options.nonce;
  return obj;
};
var applyClerkJsScriptAttributes = (options) => (script) => {
  const attributes = buildClerkJsScriptAttributes(options);
  for (const attribute in attributes) script.setAttribute(attribute, attributes[attribute]);
};

// node_modules/.pnpm/@clerk+astro@2.16.7_astro@5.16.5_@types+node@25.0.0_jiti@2.6.1_lightningcss@1.30.2_roll_d171ee5556e8a687526ed121174c4d2b/node_modules/@clerk/astro/dist/chunk-A6GFHAIE.js
var invokeClerkAstroJSFunctions = () => {
  const functionNames = ["handleRedirectCallback"];
  functionNames.forEach((fnName) => {
    const elementsOfCategory = document.querySelectorAll(`[data-clerk-function-id^="clerk-${fnName}"]`);
    elementsOfCategory.forEach((el) => {
      const id = el.getAttribute("data-clerk-function-id");
      const props = window.__astro_clerk_function_props?.get(fnName)?.get(id) ?? {};
      void $clerk.get()?.[fnName]?.(props);
    });
  });
};
var mountAllClerkAstroJSComponents = () => {
  const mountFns = {
    "create-organization": "mountCreateOrganization",
    "organization-list": "mountOrganizationList",
    "organization-profile": "mountOrganizationProfile",
    "organization-switcher": "mountOrganizationSwitcher",
    "user-avatar": "mountUserAvatar",
    "user-button": "mountUserButton",
    "user-profile": "mountUserProfile",
    "sign-in": "mountSignIn",
    "sign-up": "mountSignUp",
    "google-one-tap": "openGoogleOneTap",
    waitlist: "mountWaitlist",
    "pricing-table": "mountPricingTable",
    "api-keys": "mountAPIKeys"
  };
  Object.entries(mountFns).forEach(([category, mountFn]) => {
    const elementsOfCategory = document.querySelectorAll(`[data-clerk-id^="clerk-${category}"]`);
    elementsOfCategory.forEach((el) => {
      const clerkId = el.getAttribute("data-clerk-id");
      const props = window.__astro_clerk_component_props?.get(category)?.get(clerkId);
      if (el) {
        $clerk.get()?.[mountFn](el, props);
      }
    });
  });
};
var runOnce = (onFirst) => {
  let hasRun = false;
  return (params) => {
    if (hasRun) {
      const clerkJSInstance = window.Clerk;
      return new Promise((res) => {
        if (!clerkJSInstance) {
          return res(false);
        }
        if (clerkJSInstance.loaded) {
          mountAllClerkAstroJSComponents();
          invokeClerkAstroJSFunctions();
        }
        return res(clerkJSInstance.loaded);
      });
    }
    hasRun = true;
    return onFirst(params);
  };
};
var initOptions;
setClerkJsLoadingErrorPackageName("@clerk/astro");
function createNavigationHandler(windowNav) {
  return (to, opts) => {
    if (opts?.__internal_metadata?.navigationType === "internal") {
      windowNav(history.state, "", to);
    } else {
      opts?.windowNavigate(to);
    }
  };
}
var createClerkInstance = runOnce(createClerkInstanceInternal);
async function createClerkInstanceInternal(options) {
  let clerkJSInstance = window.Clerk;
  if (!clerkJSInstance) {
    await loadClerkJsScript(options);
    if (!window.Clerk) {
      throw new Error("Failed to download latest ClerkJS. Contact support@clerk.com.");
    }
    clerkJSInstance = window.Clerk;
  }
  if (!$clerk.get()) {
    $clerk.set(clerkJSInstance);
  }
  initOptions = {
    routerPush: createNavigationHandler(window.history.pushState.bind(window.history)),
    routerReplace: createNavigationHandler(window.history.replaceState.bind(window.history)),
    ...options
  };
  return clerkJSInstance.load(initOptions).then(() => {
    $csrState.setKey("isLoaded", true);
    $clerkStore.notify();
    mountAllClerkAstroJSComponents();
    invokeClerkAstroJSFunctions();
    clerkJSInstance.addListener((payload) => {
      $csrState.setKey("client", payload.client);
      $csrState.setKey("user", payload.user);
      $csrState.setKey("session", payload.session);
      $csrState.setKey("organization", payload.organization);
    });
  }).catch(() => {
  });
}
function updateClerkOptions(options) {
  const clerk = $clerk.get();
  if (!clerk) {
    throw new Error("Missing clerk instance");
  }
  void clerk.__unstable__updateProps({
    options: { ...initOptions, ...options },
    appearance: { ...initOptions?.appearance, ...options.appearance }
  });
}

export {
  isTruthy,
  $initialState,
  $isLoadedStore,
  $authStore,
  $userStore,
  $sessionStore,
  $organizationStore,
  $clientStore,
  $clerkStore,
  $sessionListStore,
  $signInStore,
  $signUpStore,
  createClerkInstance,
  updateClerkOptions
};
//# sourceMappingURL=chunk-MOXN5Y3W.js.map
