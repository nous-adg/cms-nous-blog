{
  "version": 3,
  "sources": ["../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/underscore.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/deriveState.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/constants.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/isomorphicAtob.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/keys.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/telemetry/throttler.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/telemetry/collector.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/telemetry/events/component-mounted.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/telemetry/events/method-called.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/telemetry/events/framework-metadata.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/telemetry/events/theme-usage.ts", "../../.pnpm/nanostores@1.0.1/node_modules/nanostores/clean-stores/index.js", "../../.pnpm/nanostores@1.0.1/node_modules/nanostores/atom/index.js", "../../.pnpm/nanostores@1.0.1/node_modules/nanostores/lifecycle/index.js", "../../.pnpm/nanostores@1.0.1/node_modules/nanostores/computed/index.js", "../../.pnpm/nanostores@1.0.1/node_modules/nanostores/map/index.js", "../../.pnpm/@clerk+astro@2.16.7_astro@5.16.5_@types+node@25.0.0_@vercel+functions@2.2.13_jiti@2.6.1_f87fcd2373d9d09b8d20f34c13878ade/node_modules/@clerk/astro/src/stores/external.ts", "../../.pnpm/@clerk+astro@2.16.7_astro@5.16.5_@types+node@25.0.0_@vercel+functions@2.2.13_jiti@2.6.1_f87fcd2373d9d09b8d20f34c13878ade/node_modules/@clerk/astro/src/stores/internal.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/createErrorTypeGuard.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/clerkApiError.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/parseError.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/clerkError.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/clerkApiResponseError.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/errorThrower.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/emailLinkError.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/clerkRuntimeError.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/webAuthNError.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/helpers.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/errors/globalHookError.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/retry.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/loadScript.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/proxy.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/url.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/versionSelector.ts", "../../.pnpm/@clerk+shared@3.39.0_react-dom@19.2.1_react@19.2.1__react@19.2.1/node_modules/@clerk/shared/src/loadClerkJsScript.ts", "../../.pnpm/@clerk+astro@2.16.7_astro@5.16.5_@types+node@25.0.0_@vercel+functions@2.2.13_jiti@2.6.1_f87fcd2373d9d09b8d20f34c13878ade/node_modules/@clerk/astro/src/internal/create-clerk-instance.ts", "../../.pnpm/@clerk+astro@2.16.7_astro@5.16.5_@types+node@25.0.0_@vercel+functions@2.2.13_jiti@2.6.1_f87fcd2373d9d09b8d20f34c13878ade/node_modules/@clerk/astro/src/internal/invoke-clerk-astro-js-functions.ts", "../../.pnpm/@clerk+astro@2.16.7_astro@5.16.5_@types+node@25.0.0_@vercel+functions@2.2.13_jiti@2.6.1_f87fcd2373d9d09b8d20f34c13878ade/node_modules/@clerk/astro/src/internal/mount-clerk-astro-js-components.ts", "../../.pnpm/@clerk+astro@2.16.7_astro@5.16.5_@types+node@25.0.0_@vercel+functions@2.2.13_jiti@2.6.1_f87fcd2373d9d09b8d20f34c13878ade/node_modules/@clerk/astro/src/internal/run-once.ts"],
  "sourcesContent": ["/**\n * Convert words to a sentence.\n *\n * @param items - An array of words to be joined.\n * @returns A string with the items joined by a comma and the last item joined by \", or\".\n */\nexport const toSentence = (items: string[]): string => {\n  // TODO: Once Safari supports it, use Intl.ListFormat\n  if (items.length == 0) {\n    return '';\n  }\n  if (items.length == 1) {\n    return items[0];\n  }\n  let sentence = items.slice(0, -1).join(', ');\n  sentence += `, or ${items.slice(-1)}`;\n  return sentence;\n};\n\nconst IP_V4_ADDRESS_REGEX =\n  /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;\n\n/**\n * Checks if a string is a valid IPv4 address.\n *\n * @returns True if the string is a valid IPv4 address, false otherwise.\n */\nexport function isIPV4Address(str: string | undefined | null): boolean {\n  return IP_V4_ADDRESS_REGEX.test(str || '');\n}\n\n/**\n * Converts the first character of a string to uppercase.\n *\n * @param str - The string to be converted.\n * @returns The modified string with the rest of the string unchanged.\n *\n * @example\n * ```ts\n * titleize('hello world') // 'Hello world'\n * ```\n */\nexport function titleize(str: string | undefined | null): string {\n  const s = str || '';\n  return s.charAt(0).toUpperCase() + s.slice(1);\n}\n\n/**\n * Converts a string from snake_case to camelCase.\n */\nexport function snakeToCamel(str: string | undefined): string {\n  return str ? str.replace(/([-_][a-z])/g, match => match.toUpperCase().replace(/-|_/, '')) : '';\n}\n\n/**\n * Converts a string from camelCase to snake_case.\n */\nexport function camelToSnake(str: string | undefined): string {\n  return str ? str.replace(/[A-Z]/g, letter => `_${letter.toLowerCase()}`) : '';\n}\n\nconst createDeepObjectTransformer = (transform: any) => {\n  const deepTransform = (obj: any): any => {\n    if (!obj) {\n      return obj;\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map(el => {\n        if (typeof el === 'object' || Array.isArray(el)) {\n          return deepTransform(el);\n        }\n        return el;\n      });\n    }\n\n    const copy = { ...obj };\n    const keys = Object.keys(copy);\n    for (const oldName of keys) {\n      const newName = transform(oldName.toString());\n      if (newName !== oldName) {\n        copy[newName] = copy[oldName];\n        delete copy[oldName];\n      }\n      if (typeof copy[newName] === 'object') {\n        copy[newName] = deepTransform(copy[newName]);\n      }\n    }\n    return copy;\n  };\n\n  return deepTransform;\n};\n\n/**\n * Transforms camelCased objects/ arrays to snake_cased.\n * This function recursively traverses all objects and arrays of the passed value\n * camelCased keys are removed.\n *\n * @function\n */\nexport const deepCamelToSnake = createDeepObjectTransformer(camelToSnake);\n\n/**\n * Transforms snake_cased objects/ arrays to camelCased.\n * This function recursively traverses all objects and arrays of the passed value\n * camelCased keys are removed.\n *\n * @function\n */\nexport const deepSnakeToCamel = createDeepObjectTransformer(snakeToCamel);\n\n/**\n * A function to determine if a value is truthy.\n *\n * @returns True for `true`, true, positive numbers. False for `false`, false, 0, negative integers and anything else.\n */\nexport function isTruthy(value: unknown): boolean {\n  // Return if Boolean\n  if (typeof value === `boolean`) {\n    return value;\n  }\n\n  // Return false if null or undefined\n  if (value === undefined || value === null) {\n    return false;\n  }\n\n  // If the String is true or false\n  if (typeof value === `string`) {\n    if (value.toLowerCase() === `true`) {\n      return true;\n    }\n\n    if (value.toLowerCase() === `false`) {\n      return false;\n    }\n  }\n\n  // Now check if it's a number\n  const number = parseInt(value as string, 10);\n  if (isNaN(number)) {\n    return false;\n  }\n\n  if (number > 0) {\n    return true;\n  }\n\n  // Default to false\n  return false;\n}\n\n/**\n * Get all non-undefined values from an object.\n */\nexport function getNonUndefinedValues<T extends object>(obj: T): Partial<T> {\n  return Object.entries(obj).reduce((acc, [key, value]) => {\n    if (value !== undefined) {\n      acc[key as keyof T] = value;\n    }\n    return acc;\n  }, {} as Partial<T>);\n}\n", "import type {\n  InitialState,\n  JwtPayload,\n  OrganizationCustomPermissionKey,\n  OrganizationCustomRoleKey,\n  OrganizationResource,\n  Resources,\n  SignedInSessionResource,\n  UserResource,\n} from './types';\n\n/**\n * Derives authentication state based on the current rendering context (SSR or client-side).\n */\nexport const deriveState = (clerkOperational: boolean, state: Resources, initialState: InitialState | undefined) => {\n  if (!clerkOperational && initialState) {\n    return deriveFromSsrInitialState(initialState);\n  }\n  return deriveFromClientSideState(state);\n};\n\nconst deriveFromSsrInitialState = (initialState: InitialState) => {\n  const userId = initialState.userId;\n  const user = initialState.user as UserResource;\n  const sessionId = initialState.sessionId;\n  const sessionStatus = initialState.sessionStatus;\n  const sessionClaims = initialState.sessionClaims;\n  const session = initialState.session as SignedInSessionResource;\n  const organization = initialState.organization as OrganizationResource;\n  const orgId = initialState.orgId;\n  const orgRole = initialState.orgRole as OrganizationCustomRoleKey;\n  const orgPermissions = initialState.orgPermissions as OrganizationCustomPermissionKey[];\n  const orgSlug = initialState.orgSlug;\n  const actor = initialState.actor;\n  const factorVerificationAge = initialState.factorVerificationAge;\n\n  return {\n    userId,\n    user,\n    sessionId,\n    session,\n    sessionStatus,\n    sessionClaims,\n    organization,\n    orgId,\n    orgRole,\n    orgPermissions,\n    orgSlug,\n    actor,\n    factorVerificationAge,\n  };\n};\n\nconst deriveFromClientSideState = (state: Resources) => {\n  const userId: string | null | undefined = state.user ? state.user.id : state.user;\n  const user = state.user;\n  const sessionId: string | null | undefined = state.session ? state.session.id : state.session;\n  const session = state.session;\n  const sessionStatus = state.session?.status;\n  const sessionClaims: JwtPayload | null | undefined = state.session\n    ? state.session.lastActiveToken?.jwt?.claims\n    : null;\n  const factorVerificationAge: [number, number] | null = state.session ? state.session.factorVerificationAge : null;\n  const actor = session?.actor;\n  const organization = state.organization;\n  const orgId: string | null | undefined = state.organization ? state.organization.id : state.organization;\n  const orgSlug = organization?.slug;\n  const membership = organization\n    ? user?.organizationMemberships?.find(om => om.organization.id === orgId)\n    : organization;\n  const orgPermissions = membership ? membership.permissions : membership;\n  const orgRole = membership ? membership.role : membership;\n\n  return {\n    userId,\n    user,\n    sessionId,\n    session,\n    sessionStatus,\n    sessionClaims,\n    organization,\n    orgId,\n    orgRole,\n    orgSlug,\n    orgPermissions,\n    actor,\n    factorVerificationAge,\n  };\n};\n", "export const LEGACY_DEV_INSTANCE_SUFFIXES = ['.lcl.dev', '.lclstage.dev', '.lclclerk.com'];\nexport const CURRENT_DEV_INSTANCE_SUFFIXES = ['.accounts.dev', '.accountsstage.dev', '.accounts.lclclerk.com'];\nexport const DEV_OR_STAGING_SUFFIXES = [\n  '.lcl.dev',\n  '.stg.dev',\n  '.lclstage.dev',\n  '.stgstage.dev',\n  '.dev.lclclerk.com',\n  '.stg.lclclerk.com',\n  '.accounts.lclclerk.com',\n  'accountsstage.dev',\n  'accounts.dev',\n];\nexport const LOCAL_ENV_SUFFIXES = ['.lcl.dev', 'lclstage.dev', '.lclclerk.com', '.accounts.lclclerk.com'];\nexport const STAGING_ENV_SUFFIXES = ['.accountsstage.dev'];\nexport const LOCAL_API_URL = 'https://api.lclclerk.com';\nexport const STAGING_API_URL = 'https://api.clerkstage.dev';\nexport const PROD_API_URL = 'https://api.clerk.com';\n\n/**\n * Returns the URL for a static image\n * using the new img.clerk.com service\n */\nexport function iconImageUrl(id: string, format: 'svg' | 'jpeg' = 'svg'): string {\n  return `https://img.clerk.com/static/${id}.${format}`;\n}\n", "/**\n * A function that decodes a string of data which has been encoded using base-64 encoding.\n * Uses `atob` if available, otherwise uses `Buffer` from `global`. If neither are available, returns the data as-is.\n */\nexport const isomorphicAtob = (data: string) => {\n  if (typeof atob !== 'undefined' && typeof atob === 'function') {\n    return atob(data);\n  } else if (typeof global !== 'undefined' && global.Buffer) {\n    return new global.Buffer(data, 'base64').toString();\n  }\n  return data;\n};\n", "import { DEV_OR_STAGING_SUFFIXES, LEGACY_DEV_INSTANCE_SUFFIXES } from './constants';\nimport { isomorphicAtob } from './isomorphicAtob';\nimport { isomorphicBtoa } from './isomorphicBtoa';\nimport type { PublishableKey } from './types';\n\n/**\n * Configuration options for parsing publishable keys.\n */\ntype ParsePublishableKeyOptions = {\n  /** Whether to throw an error if parsing fails */\n  fatal?: boolean;\n  /** Custom domain to use for satellite instances */\n  domain?: string;\n  /** Proxy URL to use instead of the decoded frontend API */\n  proxyUrl?: string;\n  /** Whether this is a satellite instance */\n  isSatellite?: boolean;\n};\n\n/** Prefix used for production publishable keys */\nconst PUBLISHABLE_KEY_LIVE_PREFIX = 'pk_live_';\n\n/** Prefix used for development publishable keys */\nconst PUBLISHABLE_KEY_TEST_PREFIX = 'pk_test_';\n\n/**\n * Regular expression that matches development frontend API keys.\n * Matches patterns like: foo-bar-13.clerk.accounts.dev.\n */\nconst PUBLISHABLE_FRONTEND_API_DEV_REGEX = /^(([a-z]+)-){2}([0-9]{1,2})\\.clerk\\.accounts([a-z.]*)(dev|com)$/i;\n\n/**\n * Converts a frontend API URL into a base64-encoded publishable key.\n *\n * @param frontendApi - The frontend API URL (e.g., 'clerk.example.com').\n * @returns A base64-encoded publishable key with appropriate prefix (pk_live_ or pk_test_).\n */\nexport function buildPublishableKey(frontendApi: string): string {\n  const isDevKey =\n    PUBLISHABLE_FRONTEND_API_DEV_REGEX.test(frontendApi) ||\n    (frontendApi.startsWith('clerk.') && LEGACY_DEV_INSTANCE_SUFFIXES.some(s => frontendApi.endsWith(s)));\n  const keyPrefix = isDevKey ? PUBLISHABLE_KEY_TEST_PREFIX : PUBLISHABLE_KEY_LIVE_PREFIX;\n  return `${keyPrefix}${isomorphicBtoa(`${frontendApi}$`)}`;\n}\n\n/**\n * Validates that a decoded publishable key has the correct format.\n * The decoded value should be a frontend API followed by exactly one '$' at the end.\n *\n * @param decoded - The decoded publishable key string to validate.\n * @returns `true` if the decoded key has valid format, `false` otherwise.\n */\nfunction isValidDecodedPublishableKey(decoded: string): boolean {\n  if (!decoded.endsWith('$')) {\n    return false;\n  }\n\n  const withoutTrailing = decoded.slice(0, -1);\n  if (withoutTrailing.includes('$')) {\n    return false;\n  }\n\n  return withoutTrailing.includes('.');\n}\n\nexport function parsePublishableKey(\n  key: string | undefined,\n  options: ParsePublishableKeyOptions & { fatal: true },\n): PublishableKey;\nexport function parsePublishableKey(\n  key: string | undefined,\n  options?: ParsePublishableKeyOptions,\n): PublishableKey | null;\n/**\n * Parses and validates a publishable key, extracting the frontend API and instance type.\n *\n * @param key - The publishable key to parse.\n * @param options - Configuration options for parsing.\n * @param options.fatal\n * @param options.domain\n * @param options.proxyUrl\n * @param options.isSatellite\n * @returns Parsed publishable key object with instanceType and frontendApi, or null if invalid.\n *\n * @throws {Error} When options.fatal is true and key is missing or invalid.\n */\nexport function parsePublishableKey(\n  key: string | undefined,\n  options: { fatal?: boolean; domain?: string; proxyUrl?: string; isSatellite?: boolean } = {},\n): PublishableKey | null {\n  key = key || '';\n\n  if (!key || !isPublishableKey(key)) {\n    if (options.fatal && !key) {\n      throw new Error(\n        'Publishable key is missing. Ensure that your publishable key is correctly configured. Double-check your environment configuration for your keys, or access them here: https://dashboard.clerk.com/last-active?path=api-keys',\n      );\n    }\n    if (options.fatal && !isPublishableKey(key)) {\n      throw new Error('Publishable key not valid.');\n    }\n    return null;\n  }\n\n  const instanceType = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) ? 'production' : 'development';\n\n  let decodedFrontendApi: string;\n  try {\n    decodedFrontendApi = isomorphicAtob(key.split('_')[2]);\n  } catch {\n    if (options.fatal) {\n      throw new Error('Publishable key not valid: Failed to decode key.');\n    }\n    return null;\n  }\n\n  if (!isValidDecodedPublishableKey(decodedFrontendApi)) {\n    if (options.fatal) {\n      throw new Error('Publishable key not valid: Decoded key has invalid format.');\n    }\n    return null;\n  }\n\n  let frontendApi = decodedFrontendApi.slice(0, -1);\n\n  if (options.proxyUrl) {\n    frontendApi = options.proxyUrl;\n  } else if (instanceType !== 'development' && options.domain && options.isSatellite) {\n    frontendApi = `clerk.${options.domain}`;\n  }\n\n  return {\n    instanceType,\n    frontendApi,\n  };\n}\n\n/**\n * Checks if the provided key is a valid publishable key.\n *\n * @param key - The key to be checked. Defaults to an empty string if not provided.\n * @returns `true` if 'key' is a valid publishable key, `false` otherwise.\n */\nexport function isPublishableKey(key: string = '') {\n  try {\n    const hasValidPrefix = key.startsWith(PUBLISHABLE_KEY_LIVE_PREFIX) || key.startsWith(PUBLISHABLE_KEY_TEST_PREFIX);\n\n    if (!hasValidPrefix) {\n      return false;\n    }\n\n    const parts = key.split('_');\n    if (parts.length !== 3) {\n      return false;\n    }\n\n    const encodedPart = parts[2];\n    if (!encodedPart) {\n      return false;\n    }\n\n    const decoded = isomorphicAtob(encodedPart);\n    return isValidDecodedPublishableKey(decoded);\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Creates a memoized cache for checking if URLs are development or staging environments.\n * Uses a Map to cache results for better performance on repeated checks.\n *\n * @returns An object with an isDevOrStagingUrl method that checks if a URL is dev/staging.\n */\nexport function createDevOrStagingUrlCache() {\n  const devOrStagingUrlCache = new Map<string, boolean>();\n\n  return {\n    /**\n     * Checks if a URL is a development or staging environment.\n     *\n     * @param url - The URL to check (string or URL object).\n     * @returns `true` if the URL is a development or staging environment, `false` otherwise.\n     */\n    isDevOrStagingUrl: (url: string | URL): boolean => {\n      if (!url) {\n        return false;\n      }\n\n      const hostname = typeof url === 'string' ? url : url.hostname;\n      let res = devOrStagingUrlCache.get(hostname);\n      if (res === undefined) {\n        res = DEV_OR_STAGING_SUFFIXES.some(s => hostname.endsWith(s));\n        devOrStagingUrlCache.set(hostname, res);\n      }\n      return res;\n    },\n  };\n}\n\n/**\n * Checks if a publishable key is for a development environment.\n * Supports both legacy format (test_) and new format (pk_test_).\n *\n * @param apiKey - The API key to check.\n * @returns `true` if the key is for development, `false` otherwise.\n */\nexport function isDevelopmentFromPublishableKey(apiKey: string): boolean {\n  return apiKey.startsWith('test_') || apiKey.startsWith('pk_test_');\n}\n\n/**\n * Checks if a publishable key is for a production environment.\n * Supports both legacy format (live_) and new format (pk_live_).\n *\n * @param apiKey - The API key to check.\n * @returns `true` if the key is for production, `false` otherwise.\n */\nexport function isProductionFromPublishableKey(apiKey: string): boolean {\n  return apiKey.startsWith('live_') || apiKey.startsWith('pk_live_');\n}\n\n/**\n * Checks if a secret key is for a development environment.\n * Supports both legacy format (test_) and new format (sk_test_).\n *\n * @param apiKey - The secret key to check.\n * @returns `true` if the key is for development, `false` otherwise.\n */\nexport function isDevelopmentFromSecretKey(apiKey: string): boolean {\n  return apiKey.startsWith('test_') || apiKey.startsWith('sk_test_');\n}\n\n/**\n * Checks if a secret key is for a production environment.\n * Supports both legacy format (live_) and new format (sk_live_).\n *\n * @param apiKey - The secret key to check.\n * @returns `true` if the key is for production, `false` otherwise.\n */\nexport function isProductionFromSecretKey(apiKey: string): boolean {\n  return apiKey.startsWith('live_') || apiKey.startsWith('sk_live_');\n}\n\n/**\n * Generates a unique cookie suffix based on the publishable key using SHA-1 hashing.\n * The suffix is base64-encoded and URL-safe (+ and / characters are replaced).\n *\n * @param publishableKey - The publishable key to generate suffix from.\n * @param subtle - The SubtleCrypto interface to use for hashing (defaults to globalThis.crypto.subtle).\n * @returns A promise that resolves to an 8-character URL-safe base64 string.\n */\nexport async function getCookieSuffix(\n  publishableKey: string,\n  subtle: SubtleCrypto = globalThis.crypto.subtle,\n): Promise<string> {\n  const data = new TextEncoder().encode(publishableKey);\n  const digest = await subtle.digest('sha-1', data);\n  const stringDigest = String.fromCharCode(...new Uint8Array(digest));\n  // Base 64 Encoding with URL and Filename Safe Alphabet: https://datatracker.ietf.org/doc/html/rfc4648#section-5\n  return isomorphicBtoa(stringDigest).replace(/\\+/gi, '-').replace(/\\//gi, '_').substring(0, 8);\n}\n\n/**\n * Creates a suffixed cookie name by appending the cookie suffix to the base name.\n * Used to create unique cookie names based on the publishable key.\n *\n * @param cookieName - The base cookie name.\n * @param cookieSuffix - The suffix to append (typically generated by getCookieSuffix).\n * @returns The suffixed cookie name in format: `${cookieName}_${cookieSuffix}`.\n */\nexport const getSuffixedCookieName = (cookieName: string, cookieSuffix: string): string => {\n  return `${cookieName}_${cookieSuffix}`;\n};\n", "import type { TelemetryEvent } from '../types';\n\ntype TtlInMilliseconds = number;\n\nconst DEFAULT_CACHE_TTL_MS = 86400000; // 24 hours\n\n/**\n * Interface for cache storage used by the telemetry throttler.\n * Implementations can use localStorage, in-memory storage, or any other storage mechanism.\n */\nexport interface ThrottlerCache {\n  getItem(key: string): TtlInMilliseconds | undefined;\n  setItem(key: string, value: TtlInMilliseconds): void;\n  removeItem(key: string): void;\n}\n\n/**\n * Manages throttling for telemetry events using a configurable cache implementation\n * to mitigate event flooding in frequently executed code paths.\n */\nexport class TelemetryEventThrottler {\n  #cache: ThrottlerCache;\n  #cacheTtl = DEFAULT_CACHE_TTL_MS;\n\n  constructor(cache: ThrottlerCache) {\n    this.#cache = cache;\n  }\n\n  isEventThrottled(payload: TelemetryEvent): boolean {\n    const now = Date.now();\n    const key = this.#generateKey(payload);\n    const entry = this.#cache.getItem(key);\n\n    if (!entry) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    const shouldInvalidate = now - entry > this.#cacheTtl;\n    if (shouldInvalidate) {\n      this.#cache.setItem(key, now);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Generates a consistent unique key for telemetry events by sorting payload properties.\n   * This ensures that payloads with identical content in different orders produce the same key.\n   */\n  #generateKey(event: TelemetryEvent): string {\n    const { sk: _sk, pk: _pk, payload, ...rest } = event;\n\n    const sanitizedEvent: Omit<TelemetryEvent, 'sk' | 'pk' | 'payload'> & TelemetryEvent['payload'] = {\n      ...payload,\n      ...rest,\n    };\n\n    return JSON.stringify(\n      Object.keys({\n        ...payload,\n        ...rest,\n      })\n        .sort()\n        .map(key => sanitizedEvent[key]),\n    );\n  }\n}\n\n/**\n * LocalStorage-based cache implementation for browser environments.\n */\nexport class LocalStorageThrottlerCache implements ThrottlerCache {\n  #storageKey = 'clerk_telemetry_throttler';\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    return this.#getCache()[key];\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    try {\n      const cache = this.#getCache();\n      cache[key] = value;\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch (err: unknown) {\n      const isQuotaExceededError =\n        err instanceof DOMException &&\n        // Check error names for different browsers\n        (err.name === 'QuotaExceededError' || err.name === 'NS_ERROR_DOM_QUOTA_REACHED');\n\n      if (isQuotaExceededError && localStorage.length > 0) {\n        // Clear our cache if quota exceeded\n        localStorage.removeItem(this.#storageKey);\n      }\n    }\n  }\n\n  removeItem(key: string): void {\n    try {\n      const cache = this.#getCache();\n      delete cache[key];\n      localStorage.setItem(this.#storageKey, JSON.stringify(cache));\n    } catch {\n      // Silently fail if we can't remove\n    }\n  }\n\n  #getCache(): Record<string, TtlInMilliseconds> {\n    try {\n      const cacheString = localStorage.getItem(this.#storageKey);\n      if (!cacheString) {\n        return {};\n      }\n      return JSON.parse(cacheString);\n    } catch {\n      return {};\n    }\n  }\n\n  static isSupported(): boolean {\n    return typeof window !== 'undefined' && !!window.localStorage;\n  }\n}\n\n/**\n * In-memory cache implementation for non-browser environments (e.g., React Native).\n */\nexport class InMemoryThrottlerCache implements ThrottlerCache {\n  #cache: Map<string, TtlInMilliseconds> = new Map();\n  #maxSize = 10000; // Defensive limit to prevent memory issues\n\n  getItem(key: string): TtlInMilliseconds | undefined {\n    // Defensive: clear cache if it gets too large\n    if (this.#cache.size > this.#maxSize) {\n      this.#cache.clear();\n      return undefined;\n    }\n\n    return this.#cache.get(key);\n  }\n\n  setItem(key: string, value: TtlInMilliseconds): void {\n    this.#cache.set(key, value);\n  }\n\n  removeItem(key: string): void {\n    this.#cache.delete(key);\n  }\n}\n", "/**\n * The `TelemetryCollector` class handles collection of telemetry events from Clerk SDKs. Telemetry is opt-out and can be disabled by setting a CLERK_TELEMETRY_DISABLED environment variable.\n * The `ClerkProvider` also accepts a `telemetry` prop that will be passed to the collector during initialization:.\n *\n * ```jsx\n * <ClerkProvider telemetry={false}>\n *    ...\n * </ClerkProvider>\n * ```\n *\n * For more information, please see the telemetry documentation page: https://clerk.com/docs/telemetry.\n */\nimport { parsePublishableKey } from '../keys';\nimport type {\n  InstanceType,\n  SDKMetadata,\n  TelemetryCollector as TelemetryCollectorInterface,\n  TelemetryEvent,\n  TelemetryEventRaw,\n  TelemetryLogEntry,\n} from '../types';\nimport { isTruthy } from '../underscore';\nimport { InMemoryThrottlerCache, LocalStorageThrottlerCache, TelemetryEventThrottler } from './throttler';\nimport type { TelemetryCollectorOptions } from './types';\n\n/**\n * Local interface for window.Clerk to avoid global type pollution.\n * This is only used within this module and doesn't affect other packages.\n */\ninterface WindowWithClerk extends Window {\n  Clerk?: {\n    constructor?: {\n      sdkMetadata?: SDKMetadata;\n    };\n  };\n}\n\n/**\n * Type guard to check if window.Clerk exists and has the expected structure.\n */\nfunction isWindowClerkWithMetadata(clerk: unknown): clerk is { constructor: { sdkMetadata?: SDKMetadata } } {\n  return (\n    typeof clerk === 'object' && clerk !== null && 'constructor' in clerk && typeof clerk.constructor === 'function'\n  );\n}\n\ntype TelemetryCollectorConfig = Pick<\n  TelemetryCollectorOptions,\n  'samplingRate' | 'disabled' | 'debug' | 'maxBufferSize' | 'perEventSampling'\n> & {\n  endpoint: string;\n};\n\ntype TelemetryMetadata = Required<\n  Pick<TelemetryCollectorOptions, 'clerkVersion' | 'sdk' | 'sdkVersion' | 'publishableKey' | 'secretKey'>\n> & {\n  /**\n   * The instance type, derived from the provided publishableKey.\n   */\n  instanceType: InstanceType;\n};\n\n/**\n * Structure of log data sent to the telemetry endpoint.\n */\ntype TelemetryLogData = {\n  /** Service that generated the log. */\n  sdk: string;\n  /** The version of the SDK where the event originated from. */\n  sdkv: string;\n  /** The version of Clerk where the event originated from. */\n  cv: string;\n  /** Log level (info, warn, error, debug, etc.). */\n  lvl: TelemetryLogEntry['level'];\n  /** Log message. */\n  msg: string;\n  /** Instance ID - optional. */\n  iid?: string;\n  /** Timestamp when log was generated. */\n  ts: string;\n  /** Primary key. */\n  pk: string | null;\n  /** Additional payload for the log. */\n  payload: Record<string, unknown> | null;\n};\n\ntype TelemetryBufferItem = { kind: 'event'; value: TelemetryEvent } | { kind: 'log'; value: TelemetryLogData };\n\n// Accepted log levels for runtime validation\nconst VALID_LOG_LEVELS = new Set<string>(['error', 'warn', 'info', 'debug', 'trace']);\n\nconst DEFAULT_CONFIG: Partial<TelemetryCollectorConfig> = {\n  samplingRate: 1,\n  maxBufferSize: 5,\n  // Production endpoint: https://clerk-telemetry.com\n  // Staging endpoint: https://staging.clerk-telemetry.com\n  // Local: http://localhost:8787\n  endpoint: 'https://clerk-telemetry.com',\n};\n\nexport class TelemetryCollector implements TelemetryCollectorInterface {\n  #config: Required<TelemetryCollectorConfig>;\n  #eventThrottler: TelemetryEventThrottler;\n  #metadata: TelemetryMetadata = {} as TelemetryMetadata;\n  #buffer: TelemetryBufferItem[] = [];\n  #pendingFlush: number | ReturnType<typeof setTimeout> | null = null;\n\n  constructor(options: TelemetryCollectorOptions) {\n    this.#config = {\n      maxBufferSize: options.maxBufferSize ?? DEFAULT_CONFIG.maxBufferSize,\n      samplingRate: options.samplingRate ?? DEFAULT_CONFIG.samplingRate,\n      perEventSampling: options.perEventSampling ?? true,\n      disabled: options.disabled ?? false,\n      debug: options.debug ?? false,\n      endpoint: DEFAULT_CONFIG.endpoint,\n    } as Required<TelemetryCollectorConfig>;\n\n    if (!options.clerkVersion && typeof window === 'undefined') {\n      // N/A in a server environment\n      this.#metadata.clerkVersion = '';\n    } else {\n      this.#metadata.clerkVersion = options.clerkVersion ?? '';\n    }\n\n    // We will try to grab the SDK data lazily when an event is triggered, so it should always be defined once the event is sent.\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdk = options.sdk!;\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.#metadata.sdkVersion = options.sdkVersion!;\n\n    this.#metadata.publishableKey = options.publishableKey ?? '';\n\n    const parsedKey = parsePublishableKey(options.publishableKey);\n    if (parsedKey) {\n      this.#metadata.instanceType = parsedKey.instanceType;\n    }\n\n    if (options.secretKey) {\n      // Only send the first 16 characters of the secret key to to avoid sending the full key. We can still query against the partial key.\n      this.#metadata.secretKey = options.secretKey.substring(0, 16);\n    }\n\n    // Use LocalStorage cache in browsers where it's supported, otherwise fall back to in-memory cache\n    const cache = LocalStorageThrottlerCache.isSupported()\n      ? new LocalStorageThrottlerCache()\n      : new InMemoryThrottlerCache();\n    this.#eventThrottler = new TelemetryEventThrottler(cache);\n  }\n\n  get isEnabled(): boolean {\n    if (this.#metadata.instanceType !== 'development') {\n      return false;\n    }\n\n    // In browser or client environments, we most likely pass the disabled option to the collector, but in environments\n    // where environment variables are available we also check for `CLERK_TELEMETRY_DISABLED`.\n    if (\n      this.#config.disabled ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DISABLED))\n    ) {\n      return false;\n    }\n\n    // navigator.webdriver is a property generally set by headless browsers that are running in an automated testing environment.\n    // Data from these environments is not meaningful for us and has the potential to produce a large volume of events, so we disable\n    // collection in this case. (ref: https://developer.mozilla.org/en-US/docs/Web/API/Navigator/webdriver)\n    if (typeof window !== 'undefined' && !!window?.navigator?.webdriver) {\n      return false;\n    }\n\n    return true;\n  }\n\n  get isDebug(): boolean {\n    return (\n      this.#config.debug ||\n      (typeof process !== 'undefined' && process.env && isTruthy(process.env.CLERK_TELEMETRY_DEBUG))\n    );\n  }\n\n  record(event: TelemetryEventRaw): void {\n    try {\n      const preparedPayload = this.#preparePayload(event.event, event.payload);\n\n      this.#logEvent(preparedPayload.event, preparedPayload);\n\n      if (!this.#shouldRecord(preparedPayload, event.eventSamplingRate)) {\n        return;\n      }\n\n      this.#buffer.push({ kind: 'event', value: preparedPayload });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry event', error);\n    }\n  }\n\n  /**\n   * Records a telemetry log entry if logging is enabled and not in debug mode.\n   *\n   * @param entry - The telemetry log entry to record.\n   */\n  recordLog(entry: TelemetryLogEntry): void {\n    try {\n      if (!this.#shouldRecordLog(entry)) {\n        return;\n      }\n\n      const levelIsValid = typeof entry?.level === 'string' && VALID_LOG_LEVELS.has(entry.level);\n      const messageIsValid = typeof entry?.message === 'string' && entry.message.trim().length > 0;\n\n      let normalizedTimestamp: Date | null = null;\n      const timestampInput: unknown = (entry as unknown as { timestamp?: unknown })?.timestamp;\n      if (typeof timestampInput === 'number' || typeof timestampInput === 'string') {\n        const candidate = new Date(timestampInput);\n        if (!Number.isNaN(candidate.getTime())) {\n          normalizedTimestamp = candidate;\n        }\n      }\n\n      if (!levelIsValid || !messageIsValid || normalizedTimestamp === null) {\n        if (this.isDebug && typeof console !== 'undefined') {\n          console.warn('[clerk/telemetry] Dropping invalid telemetry log entry', {\n            levelIsValid,\n            messageIsValid,\n            timestampIsValid: normalizedTimestamp !== null,\n          });\n        }\n        return;\n      }\n\n      const sdkMetadata = this.#getSDKMetadata();\n\n      const logData: TelemetryLogData = {\n        sdk: sdkMetadata.name,\n        sdkv: sdkMetadata.version,\n        cv: this.#metadata.clerkVersion ?? '',\n        lvl: entry.level,\n        msg: entry.message,\n        ts: normalizedTimestamp.toISOString(),\n        pk: this.#metadata.publishableKey || null,\n        payload: this.#sanitizeContext(entry.context),\n      };\n\n      this.#buffer.push({ kind: 'log', value: logData });\n\n      this.#scheduleFlush();\n    } catch (error) {\n      console.error('[clerk/telemetry] Error recording telemetry log entry', error);\n    }\n  }\n\n  #shouldRecord(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    return this.isEnabled && !this.isDebug && this.#shouldBeSampled(preparedPayload, eventSamplingRate);\n  }\n\n  #shouldRecordLog(_entry: TelemetryLogEntry): boolean {\n    // Always allow logs from debug logger to be sent. Debug logger itself is already gated elsewhere.\n    return true;\n  }\n\n  #shouldBeSampled(preparedPayload: TelemetryEvent, eventSamplingRate?: number) {\n    const randomSeed = Math.random();\n\n    const toBeSampled =\n      randomSeed <= this.#config.samplingRate &&\n      (this.#config.perEventSampling === false ||\n        typeof eventSamplingRate === 'undefined' ||\n        randomSeed <= eventSamplingRate);\n\n    if (!toBeSampled) {\n      return false;\n    }\n\n    return !this.#eventThrottler.isEventThrottled(preparedPayload);\n  }\n\n  #scheduleFlush(): void {\n    // On the server, we want to flush immediately as we have less guarantees about the lifecycle of the process\n    if (typeof window === 'undefined') {\n      this.#flush();\n      return;\n    }\n    const isBufferFull = this.#buffer.length >= this.#config.maxBufferSize;\n    if (isBufferFull) {\n      // If the buffer is full, flush immediately to make sure we minimize the chance of event loss.\n      // Cancel any pending flushes as we're going to flush immediately\n      if (this.#pendingFlush) {\n        if (typeof cancelIdleCallback !== 'undefined') {\n          cancelIdleCallback(Number(this.#pendingFlush));\n        } else {\n          clearTimeout(Number(this.#pendingFlush));\n        }\n      }\n      this.#flush();\n      return;\n    }\n\n    // If we have a pending flush, do nothing\n    if (this.#pendingFlush) {\n      return;\n    }\n\n    if ('requestIdleCallback' in window) {\n      this.#pendingFlush = requestIdleCallback(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      });\n    } else {\n      // This is not an ideal solution, but it at least waits until the next tick\n      this.#pendingFlush = setTimeout(() => {\n        this.#flush();\n        this.#pendingFlush = null;\n      }, 0);\n    }\n  }\n\n  #flush(): void {\n    // Capture the current buffer and clear it immediately to avoid closure references\n    const itemsToSend = [...this.#buffer];\n    this.#buffer = [];\n\n    this.#pendingFlush = null;\n\n    if (itemsToSend.length === 0) {\n      return;\n    }\n\n    const eventsToSend = itemsToSend\n      .filter(item => item.kind === 'event')\n      .map(item => (item as { kind: 'event'; value: TelemetryEvent }).value);\n\n    const logsToSend = itemsToSend\n      .filter(item => item.kind === 'log')\n      .map(item => (item as { kind: 'log'; value: TelemetryLogData }).value);\n\n    if (eventsToSend.length > 0) {\n      const eventsUrl = new URL('/v1/event', this.#config.endpoint);\n      fetch(eventsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        // TODO: We send an array here with that idea that we can eventually send multiple events.\n        body: JSON.stringify({ events: eventsToSend }),\n      }).catch(() => void 0);\n    }\n\n    if (logsToSend.length > 0) {\n      const logsUrl = new URL('/v1/logs', this.#config.endpoint);\n      fetch(logsUrl, {\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        keepalive: true,\n        method: 'POST',\n        body: JSON.stringify({ logs: logsToSend }),\n      }).catch(() => void 0);\n    }\n  }\n\n  /**\n   * If running in debug mode, log the event and its payload to the console.\n   */\n  #logEvent(event: TelemetryEvent['event'], payload: Record<string, any>) {\n    if (!this.isDebug) {\n      return;\n    }\n\n    if (typeof console.groupCollapsed !== 'undefined') {\n      console.groupCollapsed('[clerk/telemetry]', event);\n      console.log(payload);\n      console.groupEnd();\n    } else {\n      console.log('[clerk/telemetry]', event, payload);\n    }\n  }\n\n  /**\n   * If in browser, attempt to lazily grab the SDK metadata from the Clerk singleton, otherwise fallback to the initially passed in values.\n   *\n   * This is necessary because the sdkMetadata can be set by the host SDK after the TelemetryCollector is instantiated.\n   */\n  #getSDKMetadata() {\n    const sdkMetadata = {\n      name: this.#metadata.sdk,\n      version: this.#metadata.sdkVersion,\n    };\n\n    if (typeof window !== 'undefined') {\n      const windowWithClerk = window as WindowWithClerk;\n\n      if (windowWithClerk.Clerk) {\n        const windowClerk = windowWithClerk.Clerk;\n\n        if (isWindowClerkWithMetadata(windowClerk) && windowClerk.constructor.sdkMetadata) {\n          const { name, version } = windowClerk.constructor.sdkMetadata;\n\n          if (name !== undefined) {\n            sdkMetadata.name = name;\n          }\n          if (version !== undefined) {\n            sdkMetadata.version = version;\n          }\n        }\n      }\n    }\n\n    return sdkMetadata;\n  }\n\n  /**\n   * Append relevant metadata from the Clerk singleton to the event payload.\n   */\n  #preparePayload(event: TelemetryEvent['event'], payload: TelemetryEvent['payload']): TelemetryEvent {\n    const sdkMetadata = this.#getSDKMetadata();\n\n    return {\n      event,\n      cv: this.#metadata.clerkVersion ?? '',\n      it: this.#metadata.instanceType ?? '',\n      sdk: sdkMetadata.name,\n      sdkv: sdkMetadata.version,\n      ...(this.#metadata.publishableKey ? { pk: this.#metadata.publishableKey } : {}),\n      ...(this.#metadata.secretKey ? { sk: this.#metadata.secretKey } : {}),\n      payload,\n    };\n  }\n\n  /**\n   * Best-effort sanitization of the context payload. Returns a plain object with JSON-serializable\n   * values or null when the input is missing or not serializable. Arrays are not accepted.\n   */\n  #sanitizeContext(context: unknown): Record<string, unknown> | null {\n    if (context === null || typeof context === 'undefined') {\n      return null;\n    }\n    if (typeof context !== 'object') {\n      return null;\n    }\n    try {\n      const cleaned = JSON.parse(JSON.stringify(context));\n      if (cleaned && typeof cleaned === 'object' && !Array.isArray(cleaned)) {\n        return cleaned as Record<string, unknown>;\n      }\n      return null;\n    } catch {\n      return null;\n    }\n  }\n}\n", "import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_COMPONENT_MOUNTED = 'COMPONENT_MOUNTED';\nconst EVENT_COMPONENT_OPENED = 'COMPONENT_OPENED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\n/** Increase sampling for high-signal auth components on mount. */\nconst AUTH_COMPONENTS = new Set<string>(['SignIn', 'SignUp']);\n\n/**\n * Returns the per-event sampling rate for component-mounted telemetry events.\n * Uses a higher rate for SignIn/SignUp to improve signal quality.\n *\n *  @internal\n */\nfunction getComponentMountedSamplingRate(component: string): number {\n  return AUTH_COMPONENTS.has(component) ? 1 : EVENT_SAMPLING_RATE;\n}\n\ntype ComponentMountedBase = {\n  component: string;\n};\n\ntype EventPrebuiltComponent = ComponentMountedBase & {\n  appearanceProp: boolean;\n  elements: boolean;\n  variables: boolean;\n  baseTheme: boolean;\n};\n\ntype EventComponentMounted = ComponentMountedBase & TelemetryEventRaw['payload'];\n\n/**\n * Factory for prebuilt component telemetry events.\n *\n * @internal\n */\nfunction createPrebuiltComponentEvent(event: typeof EVENT_COMPONENT_MOUNTED | typeof EVENT_COMPONENT_OPENED) {\n  return function (\n    component: string,\n    props?: Record<string, any>,\n    additionalPayload?: TelemetryEventRaw['payload'],\n  ): TelemetryEventRaw<EventPrebuiltComponent> {\n    return {\n      event,\n      eventSamplingRate:\n        event === EVENT_COMPONENT_MOUNTED ? getComponentMountedSamplingRate(component) : EVENT_SAMPLING_RATE,\n      payload: {\n        component,\n        appearanceProp: Boolean(props?.appearance),\n        baseTheme: Boolean(props?.appearance?.baseTheme),\n        elements: Boolean(props?.appearance?.elements),\n        variables: Boolean(props?.appearance?.variables),\n        ...additionalPayload,\n      },\n    };\n  };\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is mounted.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentMounted('SignUp', props));\n */\nexport function eventPrebuiltComponentMounted(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_MOUNTED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a prebuilt (AIO) component is opened as a modal.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Will be filtered to a known list of props.\n * @param additionalPayload - Additional data to send with the event.\n * @example\n * telemetry.record(eventPrebuiltComponentOpened('GoogleOneTap', props));\n */\nexport function eventPrebuiltComponentOpened(\n  component: string,\n  props?: Record<string, any>,\n  additionalPayload?: TelemetryEventRaw['payload'],\n): TelemetryEventRaw<EventPrebuiltComponent> {\n  return createPrebuiltComponentEvent(EVENT_COMPONENT_OPENED)(component, props, additionalPayload);\n}\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for when a component is mounted. Use `eventPrebuiltComponentMounted` for prebuilt components.\n *\n * **Caution:** Filter the `props` you pass to this function to avoid sending too much data.\n *\n * @param component - The name of the component.\n * @param props - The props passed to the component. Ideally you only pass a handful of props here.\n * @example\n * telemetry.record(eventComponentMounted('SignUp', props));\n */\nexport function eventComponentMounted(\n  component: string,\n  props: TelemetryEventRaw['payload'] = {},\n): TelemetryEventRaw<EventComponentMounted> {\n  return {\n    event: EVENT_COMPONENT_MOUNTED,\n    eventSamplingRate: getComponentMountedSamplingRate(component),\n    payload: {\n      component,\n      ...props,\n    },\n  };\n}\n", "import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_METHOD_CALLED = 'METHOD_CALLED';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventMethodCalled = {\n  method: string;\n} & Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventMethodCalled(\n  method: string,\n  payload?: Record<string, unknown>,\n): TelemetryEventRaw<EventMethodCalled> {\n  return {\n    event: EVENT_METHOD_CALLED,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload: {\n      method,\n      ...payload,\n    },\n  };\n}\n", "import type { TelemetryEventRaw } from '../../types';\n\nconst EVENT_FRAMEWORK_METADATA = 'FRAMEWORK_METADATA';\nconst EVENT_SAMPLING_RATE = 0.1;\n\ntype EventFrameworkMetadata = Record<string, string | number | boolean>;\n\n/**\n * Fired when a helper method is called from a Clerk SDK.\n */\nexport function eventFrameworkMetadata(payload: EventFrameworkMetadata): TelemetryEventRaw<EventFrameworkMetadata> {\n  return {\n    event: EVENT_FRAMEWORK_METADATA,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n", "import type { Appearance, BaseTheme, TelemetryEventRaw } from '../../types';\n\nexport const EVENT_THEME_USAGE = 'THEME_USAGE';\nexport const EVENT_SAMPLING_RATE = 1;\n\ntype EventThemeUsage = {\n  /**\n   * The name of the theme being used (e.g., \"shadcn\", \"neobrutalism\", etc.).\n   */\n  themeName?: string;\n};\n\n/**\n * Helper function for `telemetry.record()`. Create a consistent event object for tracking theme usage in ClerkProvider.\n *\n * @param appearance - The appearance prop from ClerkProvider.\n * @example\n * telemetry.record(eventThemeUsage(appearance));\n */\nexport function eventThemeUsage(appearance?: Appearance): TelemetryEventRaw<EventThemeUsage> {\n  const payload = analyzeThemeUsage(appearance);\n\n  return {\n    event: EVENT_THEME_USAGE,\n    eventSamplingRate: EVENT_SAMPLING_RATE,\n    payload,\n  };\n}\n\n/**\n * Analyzes the appearance prop to extract theme usage information for telemetry.\n *\n * @internal\n */\nfunction analyzeThemeUsage(appearance?: Appearance): EventThemeUsage {\n  if (!appearance || typeof appearance !== 'object') {\n    return {};\n  }\n\n  // Prioritize the new theme property over deprecated baseTheme\n  const themeProperty = appearance.theme || appearance.baseTheme;\n\n  if (!themeProperty) {\n    return {};\n  }\n\n  let themeName: string | undefined;\n\n  if (Array.isArray(themeProperty)) {\n    // Look for the first identifiable theme name in the array\n    for (const theme of themeProperty) {\n      const name = extractThemeName(theme);\n      if (name) {\n        themeName = name;\n        break;\n      }\n    }\n  } else {\n    themeName = extractThemeName(themeProperty);\n  }\n\n  return { themeName };\n}\n\n/**\n * Extracts the theme name from a theme object.\n *\n * @internal\n */\nfunction extractThemeName(theme: BaseTheme): string | undefined {\n  if (typeof theme === 'string') {\n    return theme;\n  }\n\n  if (typeof theme === 'object' && theme !== null) {\n    // Check for explicit theme name\n    if ('name' in theme && typeof theme.name === 'string') {\n      return theme.name;\n    }\n  }\n\n  return undefined;\n}\n", "import { cleanTasks } from '../task/index.js'\n\nexport let clean = Symbol('clean')\n\nexport let cleanStores = (...stores) => {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error(\n      'cleanStores() can be used only during development or tests'\n    )\n  }\n  cleanTasks()\n  for (let $store of stores) {\n    if ($store) {\n      if ($store.mocked) delete $store.mocked\n      if ($store[clean]) $store[clean]()\n    }\n  }\n}\n", "import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\nexport let atom = initialValue => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (\n          let i = lqIndex + QUEUE_ITEMS_PER_LISTENER;\n          i < listenerQueue.length;\n\n        ) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey)\n      }\n\n      if (runListenerQueue) {\n        for (\n          lqIndex = 0;\n          lqIndex < listenerQueue.length;\n          lqIndex += QUEUE_ITEMS_PER_LISTENER\n        ) {\n          listenerQueue[lqIndex](\n            listenerQueue[lqIndex + 1],\n            listenerQueue[lqIndex + 2],\n            listenerQueue[lqIndex + 3]\n          )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n\nexport const readonlyType = store => store\n", "import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = ($store, listener) =>\n  on($store, listener, START, runListeners => {\n    let originListen = $store.listen\n    $store.listen = arg => {\n      if (!$store.lc && !$store.starting) {\n        $store.starting = true\n        runListeners()\n        delete $store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      $store.listen = originListen\n    }\n  })\n\nexport let onStop = ($store, listener) =>\n  on($store, listener, STOP, runListeners => {\n    let originOff = $store.off\n    $store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      $store.off = originOff\n    }\n  })\n\nexport let onSet = ($store, listener) =>\n  on($store, listener, SET, runListeners => {\n    let originSet = $store.set\n    let originSetKey = $store.setKey\n    if ($store.setKey) {\n      $store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...$store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    $store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      $store.set = originSet\n      $store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = ($store, listener) =>\n  on($store, listener, NOTIFY, runListeners => {\n    let originNotify = $store.notify\n    $store.notify = (oldValue, changed) => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed, oldValue })\n      if (!isAborted) return originNotify(oldValue, changed)\n    }\n    return () => {\n      $store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = ($store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) $store.events[UNMOUNT].push(destroy)\n  }\n  return on($store, listener, MOUNT, runListeners => {\n    let originListen = $store.listen\n    $store.listen = (...args) => {\n      if (!$store.lc && !$store.active) {\n        $store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = $store.off\n    $store.events[UNMOUNT] = []\n    $store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if ($store.active && !$store.lc) {\n          $store.active = false\n          for (let destroy of $store.events[UNMOUNT]) destroy()\n          $store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = $store[clean]\n      $store[clean] = () => {\n        for (let destroy of $store.events[UNMOUNT]) destroy()\n        $store.events[UNMOUNT] = []\n        $store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      $store.listen = originListen\n      $store.off = originOff\n    }\n  })\n}\n", "import { atom, epoch } from '../atom/index.js'\nimport { onMount } from '../lifecycle/index.js'\n\nlet computedStore = (stores, cb, batched) => {\n  if (!Array.isArray(stores)) stores = [stores]\n\n  let previousArgs\n  let currentEpoch\n  let set = () => {\n    if (currentEpoch === epoch) return\n    currentEpoch = epoch\n    let args = stores.map($store => $store.get())\n    if (!previousArgs || args.some((arg, i) => arg !== previousArgs[i])) {\n      previousArgs = args\n      let value = cb(...args)\n      if (value && value.then && value.t) {\n        value.then(asyncValue => {\n          if (previousArgs === args) {\n            // Prevent a stale set\n            $computed.set(asyncValue)\n          }\n        })\n      } else {\n        $computed.set(value)\n        currentEpoch = epoch\n      }\n    }\n  }\n  let $computed = atom(undefined)\n  let get = $computed.get\n  $computed.get = () => {\n    set()\n    return get()\n  }\n\n  let timer\n  let run = batched\n    ? () => {\n        clearTimeout(timer)\n        timer = setTimeout(set)\n      }\n    : set\n\n  onMount($computed, () => {\n    let unbinds = stores.map($store => $store.listen(run))\n    set()\n    return () => {\n      for (let unbind of unbinds) unbind()\n    }\n  })\n\n  return $computed\n}\n\nexport let computed = (stores, fn) => computedStore(stores, fn)\nexport let batched = (stores, fn) => computedStore(stores, fn, true)\n", "import { atom } from '../atom/index.js'\n\nexport let map = (initial = {}) => {\n  let $map = atom(initial)\n\n  $map.setKey = function (key, value) {\n    let oldMap = $map.value\n    if (typeof value === 'undefined' && key in $map.value) {\n      $map.value = { ...$map.value }\n      delete $map.value[key]\n      $map.notify(oldMap, key)\n    } else if ($map.value[key] !== value) {\n      $map.value = {\n        ...$map.value,\n        [key]: value\n      }\n      $map.notify(oldMap, key)\n    }\n  }\n\n  return $map\n}\n", "import { deriveState } from '@clerk/shared/deriveState';\nimport { eventMethodCalled } from '@clerk/shared/telemetry';\nimport type { SignedInSessionResource } from '@clerk/types';\nimport { batched, computed, onMount, type Store } from 'nanostores';\n\nimport { $clerk, $csrState, $initialState } from './internal';\n\n/**\n * A client side store that returns the loaded state of clerk-js.\n *\n * @example\n * $isLoadedStore.subscribe((authloaded => console.log(loaded))\n */\nexport const $isLoadedStore = computed([$csrState], state => state.isLoaded);\n\n/**\n * A client side store that is prepopulated with the authentication context during SSR.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $authStore.subscribe((auth) => console.log(auth.userId))\n */\nexport const $authStore = batched([$csrState, $initialState], (state, initialState) => {\n  return deriveState(\n    state.isLoaded,\n    {\n      session: state.session,\n      user: state.user,\n      organization: state.organization,\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      client: state.client!,\n    },\n    initialState,\n  );\n});\n\n/**\n * A client side store that is populated after clerk-js has loaded.\n * The store returns back the authenticated user or `null`.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $userStore.subscribe((user) => console.log(user.id))\n */\nexport const $userStore = computed([$authStore], auth => auth.user);\n\n/**\n * A client side store that is populated after clerk-js has loaded.\n * The store returns the session of the authenticated user or `null`.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $sessionStore.subscribe((session) => console.log(session.id))\n */\nexport const $sessionStore = computed([$authStore], auth => auth.session as SignedInSessionResource | null | undefined);\n\n/**\n * A client side store that is populated after clerk-js has loaded.\n * The store returns the Active Organization of the authenticated user or `null`.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $organizationStore.subscribe((org) => console.log(org.id))\n */\nexport const $organizationStore = computed([$authStore], auth => auth.organization);\n\n/**\n * A client side store that is populated after clerk-js has loaded.\n * The store returns the clerk client or `null`.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $clientStore.subscribe((client) => console.log(client.activeSessions))\n */\nexport const $clientStore = computed([$csrState], csr => csr.client);\n\n/**\n * A client side store that is populated after clerk-js is instanciated.\n * The store returns the clerk instance or `null`.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $clerkStore.subscribe((clerk) => console.log(clerk.publishableKey))\n */\nexport const $clerkStore = computed([$clerk], clerk => clerk);\n\n/**\n * A client side store that is populated after clerk-js has loaded.\n * The store returns all the sessions of the current clerk client or `null`.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $sessionListStore.subscribe((sessionList) => sessionList.map((session) => console.log('Session id:', sessino.id) ))\n */\nexport const $sessionListStore = computed([$clientStore], client => client?.sessions);\n\n/**\n * A client side store that is populated after clerk-js has loaded.\n * The store returns a `SignInResource` or `null`.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $signInStore.subscribe((signIn) => console.log(signIn.status))\n */\nexport const $signInStore = computed([$clientStore], client => client?.signIn);\n\n/**\n * A client side store that is populated after clerk-js has loaded.\n * The store returns a `SignUpResource` or `null`.\n * It is a nanostore, for instructions on how to use nanostores please review the [documentation](https://github.com/nanostores/nanostores)\n *\n * @example\n * $signUpStore.subscribe((signUp) => console.log(signUp.status))\n */\nexport const $signUpStore = computed([$clientStore], client => client?.signUp);\n\n/**\n * Records a telemetry event when a store is used to match React hooks telemetry.\n *\n * @param {Store} store - The nanostore instance to monitor.\n * @param {string} method - The name of the method associated with the store usage.\n */\nconst recordTelemetryEvent = (store: Store, method: string) => {\n  onMount(store, () => {\n    $clerk.get()?.telemetry?.record(eventMethodCalled(method));\n  });\n};\n\nrecordTelemetryEvent($signInStore, '$signInStore');\nrecordTelemetryEvent($signUpStore, '$signUpStore');\nrecordTelemetryEvent($organizationStore, '$organizationStore');\n", "import type {\n  Clerk,\n  ClientResource,\n  InitialState,\n  OrganizationResource,\n  SignedInSessionResource,\n  UserResource,\n} from '@clerk/types';\nimport { atom, map } from 'nanostores';\n\nexport const $csrState = map<{\n  isLoaded: boolean;\n  client: ClientResource | undefined | null;\n  user: UserResource | undefined | null;\n  session: SignedInSessionResource | undefined | null;\n  organization: OrganizationResource | undefined | null;\n}>({\n  isLoaded: false,\n  client: undefined,\n  user: undefined,\n  session: undefined,\n  organization: undefined,\n});\n\nexport const $initialState = map<InitialState>();\n\n// Use atom instead of `map` to prohibit key changes and allow only replacing the whole object\nexport const $clerk = atom<Clerk | null>(null);\n", "/* eslint-disable jsdoc/require-jsdoc */\n\ntype Value = unknown;\n\n/**\n * Creates a type guard function for any error class.\n * The returned function can be called as a standalone function or as a method on an error object.\n *\n * @example\n * ```typescript\n * class MyError extends Error {}\n * const isMyError = createErrorTypeGuard(MyError);\n *\n * // As a standalone function\n * if (isMyError(error)) { ... }\n *\n * // As a method (when attached to error object)\n * if (error.isMyError()) { ... }\n * ```\n */\nexport function createErrorTypeGuard<T extends new (...args: any[]) => Value>(\n  ErrorClass: T & { kind?: string },\n): {\n  (error: Value): error is InstanceType<T>;\n  (this: Value): this is InstanceType<T>;\n} {\n  function typeGuard(this: Value, error?: Value): error is InstanceType<T> {\n    const target = error ?? this;\n    if (!target) {\n      throw new TypeError(`${ErrorClass.kind || ErrorClass.name} type guard requires an error object`);\n    }\n    return target instanceof ErrorClass;\n  }\n\n  return typeGuard as {\n    (error: Value): error is InstanceType<T>;\n    (this: Value): this is InstanceType<T>;\n  };\n}\n", "import type { ClerkAPIError as ClerkAPIErrorInterface, ClerkAPIErrorJSON } from '../types';\nimport { createErrorTypeGuard } from './createErrorTypeGuard';\n\nexport type ClerkApiErrorMeta = Record<string, unknown>;\n\n/**\n * This error contains the specific error message, code, and any additional metadata that was returned by the Clerk API.\n */\nexport class ClerkAPIError<Meta extends ClerkApiErrorMeta = any> implements ClerkAPIErrorInterface {\n  static kind = 'ClerkApiError';\n  readonly code: string;\n  readonly message: string;\n  readonly longMessage: string | undefined;\n  readonly meta: Meta;\n\n  constructor(json: ClerkAPIErrorJSON) {\n    const parsedError = {\n      code: json.code,\n      message: json.message,\n      longMessage: json.long_message,\n      meta: {\n        paramName: json.meta?.param_name,\n        sessionId: json.meta?.session_id,\n        emailAddresses: json.meta?.email_addresses,\n        identifiers: json.meta?.identifiers,\n        zxcvbn: json.meta?.zxcvbn,\n        plan: json.meta?.plan,\n        isPlanUpgradePossible: json.meta?.is_plan_upgrade_possible,\n      } as unknown as Meta,\n    };\n    this.code = parsedError.code;\n    this.message = parsedError.message;\n    this.longMessage = parsedError.longMessage;\n    this.meta = parsedError.meta;\n  }\n}\n\n/**\n * Type guard to check if a value is a ClerkApiError instance.\n */\nexport const isClerkApiError = createErrorTypeGuard(ClerkAPIError);\n", "import type { ClerkAPIError as ClerkAPIErrorInterface, ClerkAPIErrorJSON } from '../types';\nimport { ClerkAPIError } from './clerkApiError';\n\n/**\n * Parses an array of ClerkAPIErrorJSON objects into an array of ClerkAPIError objects.\n *\n * @internal\n */\nexport function parseErrors(data: ClerkAPIErrorJSON[] = []): ClerkAPIErrorInterface[] {\n  return data.length > 0 ? data.map(e => new ClerkAPIError(e)) : [];\n}\n\n/**\n * Parses a ClerkAPIErrorJSON object into a ClerkAPIError object.\n *\n * @deprecated Use `ClerkAPIError` class instead\n *\n * @internal\n */\nexport function parseError(error: ClerkAPIErrorJSON): ClerkAPIErrorInterface {\n  return new ClerkAPIError(error);\n}\n\n/**\n * Converts a ClerkAPIError object into a ClerkAPIErrorJSON object.\n *\n * @internal\n */\nexport function errorToJSON(error: ClerkAPIError | null): ClerkAPIErrorJSON {\n  return {\n    code: error?.code || '',\n    message: error?.message || '',\n    long_message: error?.longMessage,\n    meta: {\n      param_name: error?.meta?.paramName,\n      session_id: error?.meta?.sessionId,\n      email_addresses: error?.meta?.emailAddresses,\n      identifiers: error?.meta?.identifiers,\n      zxcvbn: error?.meta?.zxcvbn,\n      plan: error?.meta?.plan,\n      is_plan_upgrade_possible: error?.meta?.isPlanUpgradePossible,\n    },\n  };\n}\n", "import { createErrorTypeGuard } from './createErrorTypeGuard';\n\nexport interface ClerkErrorParams {\n  /**\n   * A message that describes the error. This is typically intented to be showed to the developers.\n   * It should not be shown to the user or parsed directly as the message contents are not guaranteed\n   * to be stable - use the `code` property instead.\n   */\n  message: string;\n  /**\n   * A machine-stable code that identifies the error.\n   */\n  code: string;\n  /**\n   * A user-friendly message that describes the error and can be displayed to the user.\n   * This message defaults to English but can be usually translated to the user's language\n   * by matching the `code` property to a localized message.\n   */\n  longMessage?: string;\n  /**\n   * The cause of the error, typically an `Error` instance that was caught and wrapped by the Clerk error handler.\n   */\n  cause?: Error;\n  /**\n   * A URL to the documentation for the error.\n   */\n  docsUrl?: string;\n}\n\n/**\n * A temporary placeholder, this will eventually be replaced with a\n * build-time flag that will actually perform DCE.\n */\nconst __DEV__ = true;\n\nexport class ClerkError extends Error {\n  static kind = 'ClerkError';\n  readonly clerkError = true as const;\n  readonly code: string;\n  readonly longMessage: string | undefined;\n  readonly docsUrl: string | undefined;\n  readonly cause: Error | undefined;\n\n  get name() {\n    return this.constructor.name;\n  }\n\n  constructor(opts: ClerkErrorParams) {\n    super(new.target.formatMessage(new.target.kind, opts.message, opts.code, opts.docsUrl), { cause: opts.cause });\n    Object.setPrototypeOf(this, ClerkError.prototype);\n    this.code = opts.code;\n    this.docsUrl = opts.docsUrl;\n    this.longMessage = opts.longMessage;\n    this.cause = opts.cause;\n  }\n\n  public toString() {\n    return `[${this.name}]\\nMessage:${this.message}`;\n  }\n\n  protected static formatMessage(name: string, msg: string, code: string, docsUrl: string | undefined) {\n    // Keeping the Clerk prefix for backward compatibility\n    // msg = `${name}: ${msg.trim()}\\n\\n(code=\"${code}\")\\n\\n`;\n    // We can remove the Clerk prefix in the next major version\n    const prefix = 'Clerk:';\n    const regex = new RegExp(prefix.replace(' ', '\\\\s*'), 'i');\n    msg = msg.replace(regex, '');\n    msg = `${prefix} ${msg.trim()}\\n\\n(code=\"${code}\")\\n\\n`;\n    if (__DEV__ && docsUrl) {\n      msg += `\\n\\nDocs: ${docsUrl}`;\n    }\n    return msg;\n  }\n}\n\n/**\n * Type guard to check if a value is a ClerkError instance.\n */\nexport function isClerkError(val: unknown): val is ClerkError {\n  const typeguard = createErrorTypeGuard(ClerkError);\n  // Ths is the base error so we're being more defensive about the type guard\n  return typeguard(val) || (!!val && typeof val === 'object' && 'clerkError' in val && val.clerkError === true);\n}\n", "import type { ClerkAPIErrorJSON, ClerkAPIResponseError as ClerkAPIResponseErrorInterface } from '../types';\nimport { ClerkAPIError } from './clerkApiError';\nimport type { ClerkErrorParams } from './clerkError';\nimport { ClerkError } from './clerkError';\nimport { createErrorTypeGuard } from './createErrorTypeGuard';\n\ninterface ClerkAPIResponseOptions extends Omit<ClerkErrorParams, 'message' | 'code'> {\n  data: ClerkAPIErrorJSON[];\n  status: number;\n  clerkTraceId?: string;\n  retryAfter?: number;\n}\n\nexport class ClerkAPIResponseError extends ClerkError implements ClerkAPIResponseErrorInterface {\n  static kind = 'ClerkAPIResponseError';\n  status: number;\n  clerkTraceId?: string;\n  retryAfter?: number;\n  errors: ClerkAPIError[];\n\n  constructor(message: string, options: ClerkAPIResponseOptions) {\n    const { data: errorsJson, status, clerkTraceId, retryAfter } = options;\n    super({ ...options, message, code: 'api_response_error' });\n    Object.setPrototypeOf(this, ClerkAPIResponseError.prototype);\n    this.status = status;\n    this.clerkTraceId = clerkTraceId;\n    this.retryAfter = retryAfter;\n    this.errors = (errorsJson || []).map(e => new ClerkAPIError(e));\n  }\n\n  public toString() {\n    let message = `[${this.name}]\\nMessage:${this.message}\\nStatus:${this.status}\\nSerialized errors: ${this.errors.map(\n      e => JSON.stringify(e),\n    )}`;\n\n    if (this.clerkTraceId) {\n      message += `\\nClerk Trace ID: ${this.clerkTraceId}`;\n    }\n\n    return message;\n  }\n\n  // Override formatMessage to keep it unformatted for backward compatibility\n  protected static override formatMessage(name: string, msg: string, _: string, __: string | undefined) {\n    return msg;\n  }\n}\n\n/**\n * Type guard to check if an error is a ClerkApiResponseError.\n * Can be called as a standalone function or as a method on an error object.\n *\n * @example\n * // As a standalone function\n * if (isClerkApiResponseError(error)) { ... }\n *\n * // As a method (when attached to error object)\n * if (error.isClerkApiResponseError()) { ... }\n */\nexport const isClerkApiResponseError = createErrorTypeGuard(ClerkAPIResponseError);\n", "const DefaultMessages = Object.freeze({\n  InvalidProxyUrlErrorMessage: `The proxyUrl passed to Clerk is invalid. The expected value for proxyUrl is an absolute URL or a relative path with a leading '/'. (key={{url}})`,\n  InvalidPublishableKeyErrorMessage: `The publishableKey passed to Clerk is invalid. You can get your Publishable key at https://dashboard.clerk.com/last-active?path=api-keys. (key={{key}})`,\n  MissingPublishableKeyErrorMessage: `Missing publishableKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,\n  MissingSecretKeyErrorMessage: `Missing secretKey. You can get your key at https://dashboard.clerk.com/last-active?path=api-keys.`,\n  MissingClerkProvider: `{{source}} can only be used within the <ClerkProvider /> component. Learn more: https://clerk.com/docs/components/clerk-provider`,\n});\n\ntype MessageKeys = keyof typeof DefaultMessages;\n\ntype Messages = Record<MessageKeys, string>;\n\ntype CustomMessages = Partial<Messages>;\n\nexport type ErrorThrowerOptions = {\n  packageName: string;\n  customMessages?: CustomMessages;\n};\n\nexport interface ErrorThrower {\n  setPackageName(options: ErrorThrowerOptions): ErrorThrower;\n\n  setMessages(options: ErrorThrowerOptions): ErrorThrower;\n\n  throwInvalidPublishableKeyError(params: { key?: string }): never;\n\n  throwInvalidProxyUrl(params: { url?: string }): never;\n\n  throwMissingPublishableKeyError(): never;\n\n  throwMissingSecretKeyError(): never;\n\n  throwMissingClerkProviderError(params: { source?: string }): never;\n\n  throw(message: string): never;\n}\n\n/**\n * Builds an error thrower.\n *\n * @internal\n */\nexport function buildErrorThrower({ packageName, customMessages }: ErrorThrowerOptions): ErrorThrower {\n  let pkg = packageName;\n\n  /**\n   * Builds a message from a raw message and replacements.\n   *\n   * @internal\n   */\n  function buildMessage(rawMessage: string, replacements?: Record<string, string | number>) {\n    if (!replacements) {\n      return `${pkg}: ${rawMessage}`;\n    }\n\n    let msg = rawMessage;\n    const matches = rawMessage.matchAll(/{{([a-zA-Z0-9-_]+)}}/g);\n\n    for (const match of matches) {\n      const replacement = (replacements[match[1]] || '').toString();\n      msg = msg.replace(`{{${match[1]}}}`, replacement);\n    }\n\n    return `${pkg}: ${msg}`;\n  }\n\n  const messages = {\n    ...DefaultMessages,\n    ...customMessages,\n  };\n\n  return {\n    setPackageName({ packageName }: ErrorThrowerOptions): ErrorThrower {\n      if (typeof packageName === 'string') {\n        pkg = packageName;\n      }\n      return this;\n    },\n\n    setMessages({ customMessages }: ErrorThrowerOptions): ErrorThrower {\n      Object.assign(messages, customMessages || {});\n      return this;\n    },\n\n    throwInvalidPublishableKeyError(params: { key?: string }): never {\n      throw new Error(buildMessage(messages.InvalidPublishableKeyErrorMessage, params));\n    },\n\n    throwInvalidProxyUrl(params: { url?: string }): never {\n      throw new Error(buildMessage(messages.InvalidProxyUrlErrorMessage, params));\n    },\n\n    throwMissingPublishableKeyError(): never {\n      throw new Error(buildMessage(messages.MissingPublishableKeyErrorMessage));\n    },\n\n    throwMissingSecretKeyError(): never {\n      throw new Error(buildMessage(messages.MissingSecretKeyErrorMessage));\n    },\n\n    throwMissingClerkProviderError(params: { source?: string }): never {\n      throw new Error(buildMessage(messages.MissingClerkProvider, params));\n    },\n\n    throw(message: string): never {\n      throw new Error(buildMessage(message));\n    },\n  };\n}\n", "export class EmailLinkError extends Error {\n  code: string;\n\n  constructor(code: string) {\n    super(code);\n    this.code = code;\n    this.name = 'EmailLinkError' as const;\n    Object.setPrototypeOf(this, EmailLinkError.prototype);\n  }\n}\n\n/**\n * @deprecated Use `EmailLinkErrorCodeStatus` instead.\n *\n * @internal\n */\nexport const EmailLinkErrorCode = {\n  Expired: 'expired',\n  Failed: 'failed',\n  ClientMismatch: 'client_mismatch',\n};\n\nexport const EmailLinkErrorCodeStatus = {\n  Expired: 'expired',\n  Failed: 'failed',\n  ClientMismatch: 'client_mismatch',\n} as const;\n", "import type { ClerkErrorParams } from './clerkError';\nimport { ClerkError } from './clerkError';\nimport { createErrorTypeGuard } from './createErrorTypeGuard';\n\ntype ClerkRuntimeErrorOptions = Omit<ClerkErrorParams, 'message'>;\n\n/**\n * Custom error class for representing Clerk runtime errors.\n *\n * @class ClerkRuntimeError\n *\n * @example\n *   throw new ClerkRuntimeError('An error occurred', { code: 'password_invalid' });\n */\nexport class ClerkRuntimeError extends ClerkError {\n  static kind = 'ClerkRuntimeError';\n  /**\n   * @deprecated Use `clerkError` property instead. This property is maintained for backward compatibility.\n   */\n  readonly clerkRuntimeError = true as const;\n\n  constructor(message: string, options: ClerkRuntimeErrorOptions) {\n    super({ ...options, message });\n    Object.setPrototypeOf(this, ClerkRuntimeError.prototype);\n  }\n}\n\n/**\n * Type guard to check if an error is a ClerkRuntimeError.\n * Can be called as a standalone function or as a method on an error object.\n *\n * @example\n * // As a standalone function\n * if (isClerkRuntimeError(error)) { ... }\n *\n * // As a method (when attached to error object)\n * if (error.isClerkRuntimeError()) { ... }\n */\nexport const isClerkRuntimeError = createErrorTypeGuard(ClerkRuntimeError);\n", "import { ClerkRuntimeError } from './clerkRuntimeError';\n\ntype ClerkWebAuthnErrorCode =\n  // Generic\n  | 'passkey_not_supported'\n  | 'passkey_pa_not_supported'\n  | 'passkey_invalid_rpID_or_domain'\n  | 'passkey_already_exists'\n  | 'passkey_operation_aborted'\n  // Retrieval\n  | 'passkey_retrieval_cancelled'\n  | 'passkey_retrieval_failed'\n  // Registration\n  | 'passkey_registration_cancelled'\n  | 'passkey_registration_failed';\n\nexport class ClerkWebAuthnError extends ClerkRuntimeError {\n  /**\n   * A unique code identifying the error, can be used for localization.\n   */\n  code: ClerkWebAuthnErrorCode;\n\n  constructor(message: string, { code }: { code: ClerkWebAuthnErrorCode }) {\n    super(message, { code });\n    this.code = code;\n  }\n}\n", "import type { ClerkAPIResponseError } from './clerkApiResponseError';\nimport type { ClerkRuntimeError } from './clerkRuntimeError';\nimport type { EmailLinkError } from './emailLinkError';\nimport type { MetamaskError } from './metamaskError';\n\n/**\n * Checks if the provided error object is an unauthorized error.\n *\n * @internal\n *\n * @deprecated This is no longer used, and will be removed in the next major version.\n */\nexport function isUnauthorizedError(e: any): boolean {\n  const status = e?.status;\n  const code = e?.errors?.[0]?.code;\n  return code === 'authentication_invalid' && status === 401;\n}\n\n/**\n * Checks if the provided error object is a captcha error.\n *\n * @internal\n */\nexport function isCaptchaError(e: ClerkAPIResponseError): boolean {\n  return ['captcha_invalid', 'captcha_not_enabled', 'captcha_missing_token'].includes(e.errors[0].code);\n}\n\n/**\n * Checks if the provided error is a 4xx error.\n *\n * @internal\n */\nexport function is4xxError(e: any): boolean {\n  const status = e?.status;\n  return !!status && status >= 400 && status < 500;\n}\n\n/**\n * Checks if the provided error is a network error.\n *\n * @internal\n */\nexport function isNetworkError(e: any): boolean {\n  // TODO: revise during error handling epic\n  const message = (`${e.message}${e.name}` || '').toLowerCase().replace(/\\s+/g, '');\n  return message.includes('networkerror');\n}\n\n/**\n * Checks if the provided error is either a ClerkAPIResponseError, a ClerkRuntimeError, or a MetamaskError.\n *\n * @internal\n */\nexport function isKnownError(error: any): error is ClerkAPIResponseError | ClerkRuntimeError | MetamaskError {\n  return isClerkAPIResponseError(error) || isMetamaskError(error) || isClerkRuntimeError(error);\n}\n\n/**\n * Checks if the provided error is a ClerkAPIResponseError.\n *\n * @internal\n */\nexport function isClerkAPIResponseError(err: any): err is ClerkAPIResponseError {\n  return err && 'clerkError' in err;\n}\n\n/**\n * Checks if the provided error object is an instance of ClerkRuntimeError.\n *\n * @param err - The error object to check.\n * @returns True if the error is a ClerkRuntimeError, false otherwise.\n *\n * @example\n * const error = new ClerkRuntimeError('An error occurred');\n * if (isClerkRuntimeError(error)) {\n *   // Handle ClerkRuntimeError\n *   console.error('ClerkRuntimeError:', error.message);\n * } else {\n *   // Handle other errors\n *   console.error('Other error:', error.message);\n * }\n */\nexport function isClerkRuntimeError(err: any): err is ClerkRuntimeError {\n  return 'clerkRuntimeError' in err;\n}\n\n/**\n * Checks if the provided error is a Clerk runtime error indicating a reverification was cancelled.\n *\n * @internal\n */\nexport function isReverificationCancelledError(err: any) {\n  return isClerkRuntimeError(err) && err.code === 'reverification_cancelled';\n}\n\n/**\n * Checks if the provided error is a Metamask error.\n *\n * @internal\n */\nexport function isMetamaskError(err: any): err is MetamaskError {\n  return 'code' in err && [4001, 32602, 32603].includes(err.code) && 'message' in err;\n}\n\n/**\n * Checks if the provided error is clerk api response error indicating a user is locked.\n *\n * @internal\n */\nexport function isUserLockedError(err: any) {\n  return isClerkAPIResponseError(err) && err.errors?.[0]?.code === 'user_locked';\n}\n\n/**\n * Checks if the provided error is a clerk api response error indicating a password was pwned.\n *\n * @internal\n */\nexport function isPasswordPwnedError(err: any) {\n  return isClerkAPIResponseError(err) && err.errors?.[0]?.code === 'form_password_pwned';\n}\n\n/**\n * Checks if the provided error is a clerk api response error indicating a password was compromised.\n *\n * @internal\n */\nexport function isPasswordCompromisedError(err: any) {\n  return isClerkAPIResponseError(err) && err.errors?.[0]?.code === 'form_password_compromised';\n}\n\n/**\n * Checks if the provided error is an EmailLinkError.\n *\n * @internal\n */\nexport function isEmailLinkError(err: Error): err is EmailLinkError {\n  return err.name === 'EmailLinkError';\n}\n", "import { isClerkApiResponseError } from './clerkApiResponseError';\nimport type { ClerkError } from './clerkError';\nimport { isClerkRuntimeError } from './clerkRuntimeError';\n\n/**\n * Creates a ClerkGlobalHookError object from a ClerkError instance.\n * It's a wrapper for all the different instances of Clerk errors that can\n * be returned when using Clerk hooks.\n */\nexport function createClerkGlobalHookError(error: ClerkError) {\n  const predicates = {\n    isClerkApiResponseError,\n    isClerkRuntimeError,\n  } as const;\n\n  for (const [name, fn] of Object.entries(predicates)) {\n    Object.assign(error, { [name]: fn });\n  }\n\n  return error as ClerkError & typeof predicates;\n}\n\nexport type ClerkGlobalHookError = ReturnType<typeof createClerkGlobalHookError>;\n", "type Milliseconds = number;\n\ntype RetryOptions = Partial<{\n  /**\n   * The initial delay before the first retry.\n   *\n   * @default 125\n   */\n  initialDelay: Milliseconds;\n  /**\n   * The maximum delay between retries.\n   * The delay between retries will never exceed this value.\n   * If set to 0, the delay will increase indefinitely.\n   *\n   * @default 0\n   */\n  maxDelayBetweenRetries: Milliseconds;\n  /**\n   * The multiplier for the exponential backoff.\n   *\n   * @default 2\n   */\n  factor: number;\n  /**\n   * A function to determine if the operation should be retried.\n   * The callback accepts the error that was thrown and the number of iterations.\n   * The iterations variable references the number of retries AFTER attempt\n   * that caused the error and starts at 1 (as in, this is the 1st, 2nd, nth retry).\n   *\n   * @default (error, iterations) => iterations < 5\n   */\n  shouldRetry: (error: unknown, iterations: number) => boolean;\n  /**\n   * Controls whether the helper should retry the operation immediately once before applying exponential backoff.\n   * The delay for the immediate retry is 100ms.\n   *\n   * @default false\n   */\n  retryImmediately: boolean;\n  /**\n   * If true, the intervals will be multiplied by a factor in the range of [1,2].\n   *\n   * @default true\n   */\n  jitter: boolean;\n\n  /**\n   * A callback that is invoked before each retry attempt.\n   * The callback receives the iteration number (starting from 1 for the first retry).\n   * This can be used to modify request parameters, add headers, etc.\n   */\n  onBeforeRetry?: (iteration: number) => void | Promise<void>;\n}>;\n\nconst defaultOptions = {\n  initialDelay: 125,\n  maxDelayBetweenRetries: 0,\n  factor: 2,\n  shouldRetry: (_: unknown, iteration: number) => iteration < 5,\n  retryImmediately: false,\n  jitter: true,\n};\n\nconst RETRY_IMMEDIATELY_DELAY = 100;\n\nconst sleep = async (ms: Milliseconds) => new Promise(s => setTimeout(s, ms));\n\nconst applyJitter = (delay: Milliseconds, jitter: boolean) => {\n  return jitter ? delay * (1 + Math.random()) : delay;\n};\n\nconst createExponentialDelayAsyncFn = (\n  opts: Required<Pick<RetryOptions, 'initialDelay' | 'maxDelayBetweenRetries' | 'factor' | 'jitter'>>,\n) => {\n  let timesCalled = 0;\n\n  const calculateDelayInMs = () => {\n    const constant = opts.initialDelay;\n    const base = opts.factor;\n    let delay = constant * Math.pow(base, timesCalled);\n    delay = applyJitter(delay, opts.jitter);\n    return Math.min(opts.maxDelayBetweenRetries || delay, delay);\n  };\n\n  return async (): Promise<void> => {\n    await sleep(calculateDelayInMs());\n    timesCalled++;\n  };\n};\n\n/**\n * Retries a callback until it succeeds or the shouldRetry function returns false.\n * See {@link RetryOptions} for the available options.\n */\nexport const retry = async <T>(callback: () => T | Promise<T>, options: RetryOptions = {}): Promise<T> => {\n  let iterations = 0;\n  const { shouldRetry, initialDelay, maxDelayBetweenRetries, factor, retryImmediately, jitter, onBeforeRetry } = {\n    ...defaultOptions,\n    ...options,\n  };\n\n  const delay = createExponentialDelayAsyncFn({\n    initialDelay,\n    maxDelayBetweenRetries,\n    factor,\n    jitter,\n  });\n\n  while (true) {\n    try {\n      return await callback();\n    } catch (e) {\n      iterations++;\n      if (!shouldRetry(e, iterations)) {\n        throw e;\n      }\n\n      if (onBeforeRetry) {\n        await onBeforeRetry(iterations);\n      }\n\n      if (retryImmediately && iterations === 1) {\n        await sleep(applyJitter(RETRY_IMMEDIATELY_DELAY, jitter));\n      } else {\n        await delay();\n      }\n    }\n  }\n};\n", "import { retry } from './retry';\n\nconst NO_DOCUMENT_ERROR = 'loadScript cannot be called when document does not exist';\nconst NO_SRC_ERROR = 'loadScript cannot be called without a src';\n\ntype LoadScriptOptions = {\n  async?: boolean;\n  defer?: boolean;\n  crossOrigin?: 'anonymous' | 'use-credentials';\n  nonce?: string;\n  beforeLoad?: (script: HTMLScriptElement) => void;\n};\n\nexport async function loadScript(src = '', opts: LoadScriptOptions): Promise<HTMLScriptElement> {\n  const { async, defer, beforeLoad, crossOrigin, nonce } = opts || {};\n\n  const load = () => {\n    return new Promise<HTMLScriptElement>((resolve, reject) => {\n      if (!src) {\n        reject(new Error(NO_SRC_ERROR));\n      }\n\n      if (!document || !document.body) {\n        reject(new Error(NO_DOCUMENT_ERROR));\n      }\n\n      const script = document.createElement('script');\n\n      if (crossOrigin) {\n        script.setAttribute('crossorigin', crossOrigin);\n      }\n      script.async = async || false;\n      script.defer = defer || false;\n\n      script.addEventListener('load', () => {\n        script.remove();\n        resolve(script);\n      });\n\n      script.addEventListener('error', event => {\n        script.remove();\n        reject(event.error ?? new Error(`failed to load script: ${src}`));\n      });\n\n      script.src = src;\n      script.nonce = nonce;\n      beforeLoad?.(script);\n      document.body.appendChild(script);\n    });\n  };\n\n  return retry(load, { shouldRetry: (_, iterations) => iterations <= 5 });\n}\n", "export function isValidProxyUrl(key: string | undefined) {\n  if (!key) {\n    return true;\n  }\n\n  return isHttpOrHttps(key) || isProxyUrlRelative(key);\n}\n\nexport function isHttpOrHttps(key: string | undefined) {\n  return /^http(s)?:\\/\\//.test(key || '');\n}\n\nexport function isProxyUrlRelative(key: string) {\n  return key.startsWith('/');\n}\n\nexport function proxyUrlToAbsoluteURL(url: string | undefined): string {\n  if (!url) {\n    return '';\n  }\n  return isProxyUrlRelative(url) ? new URL(url, window.location.origin).toString() : url;\n}\n", "import { CURRENT_DEV_INSTANCE_SUFFIXES, LEGACY_DEV_INSTANCE_SUFFIXES } from './constants';\nimport { isStaging } from './utils/instance';\n\nexport function parseSearchParams(queryString = ''): URLSearchParams {\n  if (queryString.startsWith('?')) {\n    queryString = queryString.slice(1);\n  }\n  return new URLSearchParams(queryString);\n}\n\nexport function stripScheme(url = ''): string {\n  return (url || '').replace(/^.+:\\/\\//, '');\n}\n\nexport function addClerkPrefix(str: string | undefined) {\n  if (!str) {\n    return '';\n  }\n  let regex;\n  if (str.match(/^(clerk\\.)+\\w*$/)) {\n    regex = /(clerk\\.)*(?=clerk\\.)/;\n  } else if (str.match(/\\.clerk.accounts/)) {\n    return str;\n  } else {\n    regex = /^(clerk\\.)*/gi;\n  }\n\n  const stripped = str.replace(regex, '');\n  return `clerk.${stripped}`;\n}\n\n/**\n *\n * Retrieve the clerk-js major tag using the major version from the pkgVersion\n * param or use the frontendApi to determine if the canary tag should be used.\n * The default tag is `latest`.\n */\nexport const getClerkJsMajorVersionOrTag = (frontendApi: string, version?: string) => {\n  if (!version && isStaging(frontendApi)) {\n    return 'canary';\n  }\n\n  if (!version) {\n    return 'latest';\n  }\n\n  return version.split('.')[0] || 'latest';\n};\n\n/**\n *\n * Retrieve the clerk-js script url from the frontendApi and the major tag\n * using the {@link getClerkJsMajorVersionOrTag} or a provided clerkJSVersion tag.\n */\nexport const getScriptUrl = (frontendApi: string, { clerkJSVersion }: { clerkJSVersion?: string }) => {\n  const noSchemeFrontendApi = frontendApi.replace(/http(s)?:\\/\\//, '');\n  const major = getClerkJsMajorVersionOrTag(frontendApi, clerkJSVersion);\n  return `https://${noSchemeFrontendApi}/npm/@clerk/clerk-js@${clerkJSVersion || major}/dist/clerk.browser.js`;\n};\n\n// Returns true for hosts such as:\n// * accounts.foo.bar-13.lcl.dev\n// * accounts.foo.bar-13.lclstage.dev\n// * accounts.foo.bar-13.dev.lclclerk.com\nexport function isLegacyDevAccountPortalOrigin(host: string): boolean {\n  return LEGACY_DEV_INSTANCE_SUFFIXES.some(legacyDevSuffix => {\n    return host.startsWith('accounts.') && host.endsWith(legacyDevSuffix);\n  });\n}\n\n// Returns true for hosts such as:\n// * foo-bar-13.accounts.dev\n// * foo-bar-13.accountsstage.dev\n// * foo-bar-13.accounts.lclclerk.com\n// But false for:\n// * foo-bar-13.clerk.accounts.lclclerk.com\nexport function isCurrentDevAccountPortalOrigin(host: string): boolean {\n  return CURRENT_DEV_INSTANCE_SUFFIXES.some(currentDevSuffix => {\n    return host.endsWith(currentDevSuffix) && !host.endsWith('.clerk' + currentDevSuffix);\n  });\n}\n\n/* Functions below are taken from https://github.com/unjs/ufo/blob/main/src/utils.ts. LICENSE: MIT */\n\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\n\nexport function hasTrailingSlash(input = '', respectQueryAndFragment?: boolean): boolean {\n  if (!respectQueryAndFragment) {\n    return input.endsWith('/');\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\n\nexport function withTrailingSlash(input = '', respectQueryAndFragment?: boolean): string {\n  if (!respectQueryAndFragment) {\n    return input.endsWith('/') ? input : input + '/';\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || '/';\n  }\n  let path = input;\n  let fragment = '';\n  const fragmentIndex = input.indexOf('#');\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split('?');\n  return s0 + '/' + (s.length > 0 ? `?${s.join('?')}` : '') + fragment;\n}\n\nexport function withoutTrailingSlash(input = '', respectQueryAndFragment?: boolean): string {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || '/';\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || '/';\n  }\n  let path = input;\n  let fragment = '';\n  const fragmentIndex = input.indexOf('#');\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split('?');\n  return (s0.slice(0, -1) || '/') + (s.length > 0 ? `?${s.join('?')}` : '') + fragment;\n}\n\nexport function hasLeadingSlash(input = ''): boolean {\n  return input.startsWith('/');\n}\n\nexport function withoutLeadingSlash(input = ''): string {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || '/';\n}\n\nexport function withLeadingSlash(input = ''): string {\n  return hasLeadingSlash(input) ? input : '/' + input;\n}\n\nexport function cleanDoubleSlashes(input = ''): string {\n  return input\n    .split('://')\n    .map(string_ => string_.replace(/\\/{2,}/g, '/'))\n    .join('://');\n}\n\nexport function isNonEmptyURL(url: string) {\n  return url && url !== '/';\n}\n\nconst JOIN_LEADING_SLASH_RE = /^\\.?\\//;\n\nexport function joinURL(base: string, ...input: string[]): string {\n  let url = base || '';\n\n  for (const segment of input.filter(url => isNonEmptyURL(url))) {\n    if (url) {\n      // TODO: Handle .. when joining\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, '');\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n\n  return url;\n}\n\n/* Code below is taken from https://github.com/vercel/next.js/blob/fe7ff3f468d7651a92865350bfd0f16ceba27db5/packages/next/src/shared/lib/utils.ts. LICENSE: MIT */\n\n// Scheme: https://tools.ietf.org/html/rfc3986#section-3.1\n// Absolute URL: https://tools.ietf.org/html/rfc3986#section-4.3\nconst ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\\d+\\-.]*?:/;\nexport const isAbsoluteUrl = (url: string) => ABSOLUTE_URL_REGEX.test(url);\n", "/**\n * This version selector is a bit complicated, so here is the flow:\n * 1. Use the clerkJSVersion prop on the provider\n * 2. Use the exact `@clerk/clerk-js` version if it is a `@snapshot` prerelease\n * 3. Use the prerelease tag of `@clerk/clerk-js` or the packageVersion provided\n * 4. Fallback to the major version of `@clerk/clerk-js` or the packageVersion provided\n * @param clerkJSVersion - The optional clerkJSVersion prop on the provider\n * @param packageVersion - The version of `@clerk/clerk-js` that will be used if an explicit version is not provided\n * @returns The npm tag, version or major version to use\n */\nexport const versionSelector = (clerkJSVersion: string | undefined, packageVersion = JS_PACKAGE_VERSION) => {\n  if (clerkJSVersion) {\n    return clerkJSVersion;\n  }\n\n  const prereleaseTag = getPrereleaseTag(packageVersion);\n  if (prereleaseTag) {\n    if (prereleaseTag === 'snapshot') {\n      return JS_PACKAGE_VERSION;\n    }\n\n    return prereleaseTag;\n  }\n\n  return getMajorVersion(packageVersion);\n};\n\nconst getPrereleaseTag = (packageVersion: string) =>\n  packageVersion\n    .trim()\n    .replace(/^v/, '')\n    .match(/-(.+?)(\\.|$)/)?.[1];\n\nexport const getMajorVersion = (packageVersion: string) => packageVersion.trim().replace(/^v/, '').split('.')[0];\n", "import { buildErrorThrower, ClerkRuntimeError } from './error';\nimport { createDevOrStagingUrlCache, parsePublishableKey } from './keys';\nimport { loadScript } from './loadScript';\nimport { isValidProxyUrl, proxyUrlToAbsoluteURL } from './proxy';\nimport type { ClerkOptions, SDKMetadata, Without } from './types';\nimport { addClerkPrefix } from './url';\nimport { versionSelector } from './versionSelector';\n\nconst ERROR_CODE = 'failed_to_load_clerk_js';\nconst ERROR_CODE_TIMEOUT = 'failed_to_load_clerk_js_timeout';\nconst FAILED_TO_LOAD_ERROR = 'Failed to load Clerk';\n\nconst { isDevOrStagingUrl } = createDevOrStagingUrlCache();\n\nconst errorThrower = buildErrorThrower({ packageName: '@clerk/shared' });\n\n/**\n * Sets the package name for error messages during ClerkJS script loading.\n *\n * @param packageName - The name of the package to use in error messages (e.g., '@clerk/clerk-react').\n * @example\n * ```typescript\n * setClerkJsLoadingErrorPackageName('@clerk/clerk-react');\n * ```\n */\nexport function setClerkJsLoadingErrorPackageName(packageName: string) {\n  errorThrower.setPackageName({ packageName });\n}\n\ntype LoadClerkJsScriptOptions = Without<ClerkOptions, 'isSatellite'> & {\n  publishableKey: string;\n  clerkJSUrl?: string;\n  clerkJSVariant?: 'headless' | '';\n  clerkJSVersion?: string;\n  sdkMetadata?: SDKMetadata;\n  proxyUrl?: string;\n  domain?: string;\n  nonce?: string;\n  /**\n   * Timeout in milliseconds to wait for clerk-js to load before considering it failed.\n   *\n   * @default 15000 (15 seconds)\n   */\n  scriptLoadTimeout?: number;\n};\n\n/**\n * Validates that window.Clerk exists and is properly initialized.\n * This ensures we don't have false positives where the script loads but Clerk is malformed.\n *\n * @returns `true` if window.Clerk exists and has the expected structure with a load method.\n */\nfunction isClerkProperlyLoaded(): boolean {\n  if (typeof window === 'undefined' || !(window as any).Clerk) {\n    return false;\n  }\n\n  // Basic validation that window.Clerk has the expected structure\n  const clerk = (window as any).Clerk;\n  return typeof clerk === 'object' && typeof clerk.load === 'function';\n}\n\n/**\n * Checks if an existing script has a request error using Performance API.\n *\n * @param scriptUrl - The URL of the script to check.\n * @returns True if the script has failed to load due to a network/HTTP error.\n */\nfunction hasScriptRequestError(scriptUrl: string): boolean {\n  if (typeof window === 'undefined' || !window.performance) {\n    return false;\n  }\n\n  const entries = performance.getEntriesByName(scriptUrl, 'resource') as PerformanceResourceTiming[];\n\n  if (entries.length === 0) {\n    return false;\n  }\n\n  const scriptEntry = entries[entries.length - 1];\n\n  // transferSize === 0 with responseEnd === 0 indicates network failure\n  // transferSize === 0 with responseEnd > 0 might be a 4xx/5xx error or blocked request\n  if (scriptEntry.transferSize === 0 && scriptEntry.decodedBodySize === 0) {\n    // If there was no response at all, it's definitely an error\n    if (scriptEntry.responseEnd === 0) {\n      return true;\n    }\n    // If we got a response but no content, likely an HTTP error (4xx/5xx)\n    if (scriptEntry.responseEnd > 0 && scriptEntry.responseStart > 0) {\n      return true;\n    }\n\n    if ('responseStatus' in scriptEntry) {\n      const status = (scriptEntry as any).responseStatus;\n      if (status >= 400) {\n        return true;\n      }\n      if (scriptEntry.responseStatus === 0) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Waits for Clerk to be properly loaded with a timeout mechanism.\n * Uses polling to check if Clerk becomes available within the specified timeout.\n *\n * @param timeoutMs - Maximum time to wait in milliseconds.\n * @param existingScript - The existing script element to wait for. Optional, for existing scripts.\n * @returns Promise that resolves with null if Clerk loads successfully, or rejects with an error if timeout is reached.\n */\nfunction waitForClerkWithTimeout(\n  timeoutMs: number,\n  existingScript?: HTMLScriptElement,\n): Promise<HTMLScriptElement | null> {\n  return new Promise((resolve, reject) => {\n    let resolved = false;\n\n    const cleanup = (timeoutId: ReturnType<typeof setTimeout>, pollInterval: ReturnType<typeof setInterval>) => {\n      clearTimeout(timeoutId);\n      clearInterval(pollInterval);\n    };\n\n    // Bail out early if the script fails to load, instead of waiting for the entire timeout\n    existingScript?.addEventListener('error', () => {\n      cleanup(timeoutId, pollInterval);\n      reject(new ClerkRuntimeError(FAILED_TO_LOAD_ERROR, { code: ERROR_CODE }));\n    });\n\n    const checkAndResolve = () => {\n      if (resolved) {\n        return;\n      }\n\n      if (isClerkProperlyLoaded()) {\n        resolved = true;\n        cleanup(timeoutId, pollInterval);\n        resolve(null);\n      }\n    };\n\n    const handleTimeout = () => {\n      if (resolved) {\n        return;\n      }\n\n      resolved = true;\n      cleanup(timeoutId, pollInterval);\n\n      if (!isClerkProperlyLoaded()) {\n        reject(new ClerkRuntimeError(FAILED_TO_LOAD_ERROR, { code: ERROR_CODE_TIMEOUT }));\n      } else {\n        resolve(null);\n      }\n    };\n\n    const timeoutId = setTimeout(handleTimeout, timeoutMs);\n\n    checkAndResolve();\n\n    const pollInterval = setInterval(() => {\n      if (resolved) {\n        clearInterval(pollInterval);\n        return;\n      }\n      checkAndResolve();\n    }, 100);\n  });\n}\n\n/**\n * Hotloads the Clerk JS script with robust failure detection and retry logic.\n *\n * For existing scripts:\n * - If no request error detected: waits for timeout, then retries with loadScript if timeout expires\n * - If request error detected: immediately retries with loadScript.\n *\n * For new scripts: uses loadScript which has built-in retry logic via the retry utility.\n *\n * @param opts - The options used to build the Clerk JS script URL and load the script.\n *               Must include a `publishableKey` if no existing script is found.\n * @returns Promise that resolves with null if Clerk loads successfully, or rejects with an error.\n *\n * @example\n * ```typescript\n * try {\n *   await loadClerkJsScript({ publishableKey: 'pk_test_...' });\n *   console.log('Clerk loaded successfully');\n * } catch (error) {\n *   console.error('Failed to load Clerk:', error.message);\n * }\n * ```\n */\nconst loadClerkJsScript = async (opts?: LoadClerkJsScriptOptions): Promise<HTMLScriptElement | null> => {\n  const timeout = opts?.scriptLoadTimeout ?? 15000;\n\n  if (isClerkProperlyLoaded()) {\n    return null;\n  }\n\n  if (!opts?.publishableKey) {\n    errorThrower.throwMissingPublishableKeyError();\n    return null;\n  }\n\n  const scriptUrl = clerkJsScriptUrl(opts);\n  const existingScript = document.querySelector<HTMLScriptElement>('script[data-clerk-js-script]');\n\n  if (existingScript) {\n    if (hasScriptRequestError(scriptUrl)) {\n      existingScript.remove();\n    } else {\n      try {\n        await waitForClerkWithTimeout(timeout, existingScript);\n        return null;\n      } catch {\n        existingScript.remove();\n      }\n    }\n  }\n\n  const loadPromise = waitForClerkWithTimeout(timeout);\n\n  loadScript(scriptUrl, {\n    async: true,\n    crossOrigin: 'anonymous',\n    nonce: opts.nonce,\n    beforeLoad: applyClerkJsScriptAttributes(opts),\n  }).catch(error => {\n    throw new ClerkRuntimeError(FAILED_TO_LOAD_ERROR + (error.message ? `, ${error.message}` : ''), {\n      code: ERROR_CODE,\n      cause: error,\n    });\n  });\n\n  return loadPromise;\n};\n\n/**\n * Generates a Clerk JS script URL based on the provided options.\n *\n * @param opts - The options to use when building the Clerk JS script URL.\n * @returns The complete URL to the Clerk JS script.\n *\n * @example\n * ```typescript\n * const url = clerkJsScriptUrl({ publishableKey: 'pk_test_...' });\n * // Returns: \"https://example.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js\"\n * ```\n */\nconst clerkJsScriptUrl = (opts: LoadClerkJsScriptOptions) => {\n  const { clerkJSUrl, clerkJSVariant, clerkJSVersion, proxyUrl, domain, publishableKey } = opts;\n\n  if (clerkJSUrl) {\n    return clerkJSUrl;\n  }\n\n  let scriptHost = '';\n  if (!!proxyUrl && isValidProxyUrl(proxyUrl)) {\n    scriptHost = proxyUrlToAbsoluteURL(proxyUrl).replace(/http(s)?:\\/\\//, '');\n  } else if (domain && !isDevOrStagingUrl(parsePublishableKey(publishableKey)?.frontendApi || '')) {\n    scriptHost = addClerkPrefix(domain);\n  } else {\n    scriptHost = parsePublishableKey(publishableKey)?.frontendApi || '';\n  }\n\n  const variant = clerkJSVariant ? `${clerkJSVariant.replace(/\\.+$/, '')}.` : '';\n  const version = versionSelector(clerkJSVersion);\n  return `https://${scriptHost}/npm/@clerk/clerk-js@${version}/dist/clerk.${variant}browser.js`;\n};\n\n/**\n * Builds an object of Clerk JS script attributes based on the provided options.\n *\n * @param options - The options containing the values for script attributes.\n * @returns An object containing data attributes to be applied to the script element.\n */\nconst buildClerkJsScriptAttributes = (options: LoadClerkJsScriptOptions) => {\n  const obj: Record<string, string> = {};\n\n  if (options.publishableKey) {\n    obj['data-clerk-publishable-key'] = options.publishableKey;\n  }\n\n  if (options.proxyUrl) {\n    obj['data-clerk-proxy-url'] = options.proxyUrl;\n  }\n\n  if (options.domain) {\n    obj['data-clerk-domain'] = options.domain;\n  }\n\n  if (options.nonce) {\n    obj.nonce = options.nonce;\n  }\n\n  return obj;\n};\n\n/**\n * Returns a function that applies Clerk JS script attributes to a script element.\n *\n * @param options - The options containing the values for script attributes.\n * @returns A function that accepts a script element and applies the attributes to it.\n */\nconst applyClerkJsScriptAttributes = (options: LoadClerkJsScriptOptions) => (script: HTMLScriptElement) => {\n  const attributes = buildClerkJsScriptAttributes(options);\n  for (const attribute in attributes) {\n    script.setAttribute(attribute, attributes[attribute]);\n  }\n};\n\nexport { buildClerkJsScriptAttributes, clerkJsScriptUrl, loadClerkJsScript };\nexport type { LoadClerkJsScriptOptions };\n", "import { loadClerkJsScript, setClerkJsLoadingErrorPackageName } from '@clerk/shared/loadClerkJsScript';\nimport type { ClerkOptions } from '@clerk/types';\n\nimport { $clerkStore } from '../stores/external';\nimport { $clerk, $csrState } from '../stores/internal';\nimport type { AstroClerkCreateInstanceParams, AstroClerkUpdateOptions } from '../types';\nimport { invokeClerkAstroJSFunctions } from './invoke-clerk-astro-js-functions';\nimport { mountAllClerkAstroJSComponents } from './mount-clerk-astro-js-components';\nimport { runOnce } from './run-once';\n\nlet initOptions: ClerkOptions | undefined;\n\nsetClerkJsLoadingErrorPackageName(PACKAGE_NAME);\n\nfunction createNavigationHandler(\n  windowNav: typeof window.history.pushState | typeof window.history.replaceState,\n): Exclude<ClerkOptions['routerPush'], undefined> | Exclude<ClerkOptions['routerReplace'], undefined> {\n  return (to, opts) => {\n    if (opts?.__internal_metadata?.navigationType === 'internal') {\n      windowNav(history.state, '', to);\n    } else {\n      opts?.windowNavigate(to);\n    }\n  };\n}\n\n/**\n * Prevents firing clerk.load() multiple times\n */\nconst createClerkInstance = runOnce(createClerkInstanceInternal);\n\nasync function createClerkInstanceInternal(options?: AstroClerkCreateInstanceParams) {\n  let clerkJSInstance = window.Clerk;\n  if (!clerkJSInstance) {\n    await loadClerkJsScript(options);\n\n    if (!window.Clerk) {\n      throw new Error('Failed to download latest ClerkJS. Contact support@clerk.com.');\n    }\n    clerkJSInstance = window.Clerk;\n  }\n\n  if (!$clerk.get()) {\n    $clerk.set(clerkJSInstance);\n  }\n\n  initOptions = {\n    routerPush: createNavigationHandler(window.history.pushState.bind(window.history)),\n    routerReplace: createNavigationHandler(window.history.replaceState.bind(window.history)),\n    ...options,\n  };\n\n  return clerkJSInstance\n    .load(initOptions)\n    .then(() => {\n      $csrState.setKey('isLoaded', true);\n      // Notify subscribers that $clerkStore has been loaded.\n      // We're doing this because nanostores uses `===` for equality\n      // and just by setting the value to `window.Clerk` again won't trigger an update.\n      // We notify only once as this store is for advanced users.\n      $clerkStore.notify();\n\n      mountAllClerkAstroJSComponents();\n      invokeClerkAstroJSFunctions();\n\n      clerkJSInstance.addListener(payload => {\n        $csrState.setKey('client', payload.client);\n        $csrState.setKey('user', payload.user);\n        $csrState.setKey('session', payload.session);\n        $csrState.setKey('organization', payload.organization);\n      });\n    })\n    .catch(() => {});\n}\n\nfunction updateClerkOptions(options: AstroClerkUpdateOptions) {\n  const clerk = $clerk.get();\n  if (!clerk) {\n    throw new Error('Missing clerk instance');\n  }\n  // `__unstable__updateProps` is not exposed as public API from `@clerk/types`\n  void (clerk as any).__unstable__updateProps({\n    options: { ...initOptions, ...options },\n    appearance: { ...initOptions?.appearance, ...options.appearance },\n  });\n}\n\nexport { createClerkInstance, updateClerkOptions };\n", "import { $clerk } from '../stores/internal';\n\n/**\n * Loop through any Astro component that has requested to invoke a function and invoke it with its respective props.\n */\nconst invokeClerkAstroJSFunctions = () => {\n  const functionNames = ['handleRedirectCallback'] as const;\n\n  functionNames.forEach(fnName => {\n    const elementsOfCategory = document.querySelectorAll(`[data-clerk-function-id^=\"clerk-${fnName}\"]`);\n    elementsOfCategory.forEach(el => {\n      const id = el.getAttribute('data-clerk-function-id');\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const props = window.__astro_clerk_function_props?.get(fnName)?.get(id!) ?? {};\n      void $clerk.get()?.[fnName]?.(props);\n    });\n  });\n};\n\nexport { invokeClerkAstroJSFunctions };\n", "import type { Clerk } from '@clerk/types';\n\nimport { $clerk } from '../stores/internal';\nimport type { InternalUIComponentId } from '../types';\n\n/**\n * Loop through any Astro component that has requested to mount a UI component and mount it with its respective props.\n */\nconst mountAllClerkAstroJSComponents = () => {\n  const mountFns = {\n    'create-organization': 'mountCreateOrganization',\n    'organization-list': 'mountOrganizationList',\n    'organization-profile': 'mountOrganizationProfile',\n    'organization-switcher': 'mountOrganizationSwitcher',\n    'user-avatar': 'mountUserAvatar',\n    'user-button': 'mountUserButton',\n    'user-profile': 'mountUserProfile',\n    'sign-in': 'mountSignIn',\n    'sign-up': 'mountSignUp',\n    'google-one-tap': 'openGoogleOneTap',\n    waitlist: 'mountWaitlist',\n    'pricing-table': 'mountPricingTable',\n    'api-keys': 'mountAPIKeys',\n  } as const satisfies Record<InternalUIComponentId, keyof Clerk>;\n\n  Object.entries(mountFns).forEach(([category, mountFn]) => {\n    const elementsOfCategory = document.querySelectorAll(`[data-clerk-id^=\"clerk-${category}\"]`);\n    elementsOfCategory.forEach(el => {\n      const clerkId = el.getAttribute('data-clerk-id') as string;\n      const props = window.__astro_clerk_component_props?.get(category)?.get(clerkId);\n      if (el) {\n        $clerk.get()?.[mountFn](el as HTMLDivElement, props);\n      }\n    });\n  });\n};\n\nexport { mountAllClerkAstroJSComponents };\n", "import { invokeClerkAstroJSFunctions } from './invoke-clerk-astro-js-functions';\nimport { mountAllClerkAstroJSComponents } from './mount-clerk-astro-js-components';\nimport type { CreateClerkInstanceInternalFn } from './types';\n\n/**\n * Prevents mounting components multiple times when the `createClerkInstanceInternal` was been called twice without await first\n * This is useful as the \"integration\" may call the function twice at the same time.\n */\nconst runOnce = (onFirst: CreateClerkInstanceInternalFn) => {\n  let hasRun = false;\n  return (params: Parameters<CreateClerkInstanceInternalFn>[0]) => {\n    if (hasRun) {\n      const clerkJSInstance = window.Clerk;\n      return new Promise(res => {\n        if (!clerkJSInstance) {\n          return res(false);\n        }\n\n        if (clerkJSInstance.loaded) {\n          mountAllClerkAstroJSComponents();\n          invokeClerkAstroJSFunctions();\n        }\n        return res(clerkJSInstance.loaded);\n      });\n    }\n    /**\n     * Probably html streaming has delayed the component from mounting immediately.\n     * In Astro, js modules will start executing only after html streaming has ended.\n     */\n    hasRun = true;\n    return onFirst(params);\n  };\n};\n\nexport { runOnce };\n"],
  "mappings": "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",
  "names": ["userId: string | null | undefined", "sessionId: string | null | undefined", "sessionClaims: JwtPayload | null | undefined", "factorVerificationAge: [number, number] | null", "orgId: string | null | undefined", "decodedFrontendApi: string", "EVENT_SAMPLING_RATE", "batched", "ClerkError", "ClerkAPIResponseError", "packageName", "customMessages", "ClerkRuntimeError", "isClerkRuntimeError", "timeoutId", "pollInterval", "obj: Record<string, string>"]
}
